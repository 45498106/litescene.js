<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/components/components.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/LS.ComponentContainer.html">LS.ComponentContainer</a></li>
            
                <li><a href="../classes/LS.Components.Camera.html">LS.Components.Camera</a></li>
            
                <li><a href="../classes/LS.Components.FaceTo.html">LS.Components.FaceTo</a></li>
            
                <li><a href="../classes/LS.Components.FollowNode.html">LS.Components.FollowNode</a></li>
            
                <li><a href="../classes/LS.Components.FPSController.html">LS.Components.FPSController</a></li>
            
                <li><a href="../classes/LS.Components.GeometricPrimitive.html">LS.Components.GeometricPrimitive</a></li>
            
                <li><a href="../classes/LS.Components.GraphComponent.html">LS.Components.GraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.KnobComponent.html">LS.Components.KnobComponent</a></li>
            
                <li><a href="../classes/LS.Components.Light.html">LS.Components.Light</a></li>
            
                <li><a href="../classes/LS.Components.RealtimeReflector.html">LS.Components.RealtimeReflector</a></li>
            
                <li><a href="../classes/LS.Components.Rotator.html">LS.Components.Rotator</a></li>
            
                <li><a href="../classes/LS.Components.Transform.html">LS.Components.Transform</a></li>
            
                <li><a href="../classes/LS.Context.html">LS.Context</a></li>
            
                <li><a href="../classes/LS.LS.html">LS.LS</a></li>
            
                <li><a href="../classes/LS.Material.html">LS.Material</a></li>
            
                <li><a href="../classes/LS.Renderer.html">LS.Renderer</a></li>
            
                <li><a href="../classes/LS.ResourcesManager.html">LS.ResourcesManager</a></li>
            
                <li><a href="../classes/LS.SceneNode.html">LS.SceneNode</a></li>
            
                <li><a href="../classes/LS.SceneTree.html">LS.SceneTree</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/components/components.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/* Components allow to add custom behaviour to nodes */

//***************************************************

/**
* GeometricPrimitive renders a primitive
* @class GeometricPrimitive
* @constructor
* @param {String} object to configure from
*/

function GeometricPrimitive(o)
{
	//this.size = 10;
	this.two_sided = false;
	this.geometry = GeometricPrimitive.CUBE;
	this.align_z = false;
	if(!GeometricPrimitive.MESHES)
		GeometricPrimitive.MESHES = {};

	if(o)
		this.configure(o);
}

GeometricPrimitive.CUBE = 1;
GeometricPrimitive.PLANE = 2;
GeometricPrimitive.CYLINDER = 3;
GeometricPrimitive.SPHERE = 4;

GeometricPrimitive.MESHES = null;
GeometricPrimitive[&quot;@geometry&quot;] = { type:&quot;enum&quot;, values: {&quot;Cube&quot;:GeometricPrimitive.CUBE, &quot;Plane&quot;: GeometricPrimitive.PLANE, &quot;Cylinder&quot;:GeometricPrimitive.CYLINDER,  &quot;Sphere&quot;:GeometricPrimitive.SPHERE }};

/**
* Configure the component getting the info from the object
* @method configure
* @param {Object} object to configure from
*/

GeometricPrimitive.prototype.configure = function(o)
{
	cloneObject(o, this);
}

/**
* Serialize this component)
* @method serialize
* @return {Object} object with the serialization info
*/

GeometricPrimitive.prototype.serialize = function()
{
	 var o = cloneObject(this);
	 return o;
}

GeometricPrimitive.prototype.getRenderInstance = function()
{
	//if(this.size == 0) return;
	var mesh = null;

	if(this.geometry == GeometricPrimitive.CUBE)
	{
		if(!GeometricPrimitive.MESHES[GeometricPrimitive.CUBE])
			GeometricPrimitive.MESHES[GeometricPrimitive.CUBE] = GL.Mesh.cube({normals:true,coords:true});
		mesh = GeometricPrimitive.MESHES[GeometricPrimitive.CUBE];
	}
	else if(this.geometry == GeometricPrimitive.PLANE)
	{
		if(!GeometricPrimitive.MESHES[GeometricPrimitive.PLANE])
			GeometricPrimitive.MESHES[GeometricPrimitive.PLANE] = GL.Mesh.plane({xz:true,normals:true,coords:true});
		mesh = GeometricPrimitive.MESHES[GeometricPrimitive.PLANE];
	}
	else if(this.geometry == GeometricPrimitive.CYLINDER)
	{
		if(!GeometricPrimitive.MESHES[GeometricPrimitive.CYLINDER])
			GeometricPrimitive.MESHES[GeometricPrimitive.CYLINDER] = GL.Mesh.cylinder({normals:true,coords:true});
		mesh = GeometricPrimitive.MESHES[GeometricPrimitive.CYLINDER];
	}
	else if(this.geometry == GeometricPrimitive.SPHERE)
	{
		if(!GeometricPrimitive.MESHES[GeometricPrimitive.SPHERE])
			GeometricPrimitive.MESHES[GeometricPrimitive.SPHERE] = GL.Mesh.sphere({&quot;long&quot;:32,&quot;lat&quot;:32,normals:true,coords:true});
		mesh = GeometricPrimitive.MESHES[GeometricPrimitive.SPHERE];
	}
	else 
		return null;

	var matrix = mat4.clone( this._root.transform.getGlobalMatrix() );
	if(this.align_z)
	{
		mat4.rotateX( matrix, matrix, Math.PI * -0.5 );
		//mat4.rotateZ( matrix, Math.PI );
	}
	//mat4.scale(matrix, [this.size,this.size,this.size]);
	var center = mat4.multiplyVec3(vec3.create(), matrix, vec3.create());

	if(this._root) this._root.mesh = mesh;

	return { 
		mesh: mesh,
		material: this.material || this._root.material,
		two_sided: this.two_sided,
		matrix: matrix,
		center: center
	};
}

LS.registerComponent(GeometricPrimitive);

//*******************************************************

function FogFX(o)
{
	this.enabled = true;
	this.start = 100;
	this.end = 1000;
	this.density = 0.001;
	this.type = FogFX.LINEAR;
	this.color = vec3.fromValues(0.5,0.5,0.5);

	if(o)
		this.configure(o);
}

FogFX.LINEAR = 1;
FogFX.EXP = 2;
FogFX.EXP2 = 3;

FogFX[&quot;@color&quot;] = { type: &quot;color&quot; };
FogFX[&quot;@density&quot;] = { type: &quot;number&quot;, min: 0, max:1, step:0.0001, precision: 4 };
FogFX[&quot;@type&quot;] = { type:&quot;enum&quot;, values: {&quot;linear&quot;: FogFX.LINEAR, &quot;exponential&quot;: FogFX.EXP, &quot;exponential 2&quot;: FogFX.EXP2 }};


FogFX.prototype.onAddedToNode = function(node)
{
	LEvent.bind(Scene,&quot;fillLightUniforms&quot;,this.fillUniforms,this);
	LEvent.bind(Scene,&quot;fillMacros&quot;,this.fillMacros,this);
}

FogFX.prototype.onRemovedFromNode = function(node)
{
	LEvent.unbind(Scene,&quot;fillLightUniforms&quot;,this.fillUniforms,this);
	LEvent.unbind(Scene,&quot;fillMacros&quot;,this.fillMacros,this);
}

FogFX.prototype.fillUniforms = function(e, pass)
{
	if(!this.enabled) return;

	pass.uniforms.u_fog_info = [this.start, this.end, this.density ];

	if(pass.light == pass.lights[0])
		pass.uniforms.u_fog_color = this.color;
	else
		pass.uniforms.u_fog_color = [0,0,0];
}

FogFX.prototype.fillMacros = function(e, pass)
{
	if(!this.enabled) return;

	var macros = pass.macros;
	macros.USE_FOG = &quot;&quot;
	switch(this.type)
	{
		case FogFX.EXP:	macros.USE_FOG_EXP = &quot;&quot;; break;
		case FogFX.EXP2: macros.USE_FOG_EXP2 = &quot;&quot;; break;
	}
}

LS.registerComponent(FogFX);


//*******************************************************

/*
function TargetComponent(o)
{
}
*/

//*******************************************************


function TerrainRenderer(o)
{
	this.height = 2;
	this.size = 10;

	this.subdivisions = 10;
	this.heightmap = null;
	this.auto_update = true;
	this._mesh = null;
	this.action = &quot;Update&quot;; //button
	if(o)
		this.configure(o);
}

/**
* Configure the component getting the info from the object
* @method configure
* @param {Object} object to configure from
*/

TerrainRenderer.prototype.configure = function(o)
{
	cloneObject(o, this);
}

/**
* Serialize this component)
* @method serialize
* @return {Object} object with the serialization info
*/

TerrainRenderer.prototype.serialize = function()
{
	 var o = cloneObject(this);
	 return o;
}

TerrainRenderer.prototype.getResources = function(res)
{
	if(this.heightmap)
		res[ this.heightmap ] = Texture;
}

TerrainRenderer[&quot;@subdivisions&quot;] = { widget: &quot;number&quot;, min:1,max:255,step:1 };
TerrainRenderer[&quot;@heightmap&quot;] = { widget: &quot;texture&quot; };
TerrainRenderer[&quot;@action&quot;] = { widget: &quot;button&quot;, callback: function() { this.options.component.updateMesh(); }};

TerrainRenderer.prototype.updateMesh = function()
{
	trace(&quot;updating terrain mesh...&quot;);
	//check that we have all the data
	if(!this.heightmap) return;
	var heightmap = typeof(this.heightmap) == &quot;string&quot; ? ResourcesManager.textures[this.heightmap] : this.heightmap;
	if(!heightmap) return;
	var img = heightmap.img;
	if(!img) return;

	if(this.subdivisions &gt; img.width)
		this.subdivisions = img.width;
	if(this.subdivisions &gt; img.height)
		this.subdivisions = img.height;

	if(this.subdivisions &gt; 255)	this.subdivisions = 255; //MAX because of indexed nature

	//optimize it
	var size = this.size;
	var subdivisions = (this.subdivisions)&lt;&lt;0;
	var height = this.height;

	//get the pixels
	var canvas = createCanvas(subdivisions,subdivisions);
	var ctx = canvas.getContext(&quot;2d&quot;);
	ctx.drawImage(img,0,0,img.width,img.height,0,0,canvas.width, canvas.height);
	//$(&quot;body&quot;).append(canvas);

	var pixels = ctx.getImageData(0, 0, canvas.width, canvas.height);
	var data = pixels.data;

	//create the mesh
	var triangles = [];
	var vertices = [];
	var normals = [];
	var coords = [];

	var detailY = detailX = subdivisions-1;
	var h,lh,th,rh,bh = 0;

	var yScale = height;
	var xzScale = size / (subdivisions-1);

	for (var y = 0; y &lt;= detailY; y++) 
	{
		var t = y / detailY;
		for (var x = 0; x &lt;= detailX; x++) 
		{
			var s = x / detailX;

			h = data[y * subdivisions * 4 + x * 4] / 255; //red channel
			vertices.push(size*(2 * s - 1), h * height, size*(2 * t - 1));
			coords.push(s,1-t);

			if(x == 0 || y == 0 || x == detailX-1 || y == detailY-1)
				normals.push(0, 1, 0);
			else
			{
				var sX = (data[y * subdivisions * 4 + (x+1) * 4] / 255) - (data[y * subdivisions * 4 + (x-1) * 4] / 255);
				var sY = (data[(y+1) * subdivisions * 4 + x * 4] / 255) - (data[(y-1) * subdivisions * 4 + x * 4] / 255);
				var N = [-sX*yScale,2*xzScale,-sY*yScale];
				vec3.normalize(N,N);
				normals.push(N[0],N[1],N[2]);
			}

			//add triangle
			if (x &lt; detailX &amp;&amp; y &lt; detailY)
			{
				var i = x + y * (detailX + 1);
				triangles.push(i+1, i, i + detailX + 1);
				triangles.push(i + 1, i + detailX + 1, i + detailX + 2);
			}
		}
	}

	var mesh = Mesh.load({triangles:triangles,vertices:vertices,normals:normals,coords:coords});
	this._mesh = mesh;
	this._info = [ this.heightmap, this.size, this.height, this.subdivisions, this.smooth ];
}

TerrainRenderer.PLANE = null;

TerrainRenderer.prototype.getRenderInstance = function()
{
	if(!this._mesh &amp;&amp; this.heightmap)
		this.updateMesh();

	if(this.auto_update &amp;&amp; this._info)
	{
		if( this._info[0] != this.heightmap || this._info[1] != this.size || this._info[2] != this.height || this._info[3] != this.subdivisions || this._info[4] != this.smooth )
			this.updateMesh();
	}

	if(!this._mesh)
	{
		if(!TerrainRenderer.PLANE)
			TerrainRenderer.PLANE = GL.Mesh.plane({xz:true,normals:true,coords:true});	
		return { mesh: TerrainRenderer.PLANE }
	};

	return { 
		mesh: this._mesh
	};
}

LS.registerComponent(TerrainRenderer);


/**
* FollowNode 
* @class FollowNode
* @constructor
* @param {String} object to configure from
*/

function FollowNode(o)
{
	this.node_name = &quot;&quot;;
	this.fixed_y = false;
	this.follow_camera = false;
	if(o)
		this.configure(o);
}

FollowNode.prototype.onAddedToNode = function(node)
{
	LEvent.bind(node,&quot;computeVisibility&quot;,this.updatePosition,this);
}

FollowNode.prototype.updatePosition = function(e,info)
{
	if(!this._root) return;

	var pos = null;

	if(this.follow_camera)
		pos =  info.camera.getEye();
	else
	{
		var target_node = Scene.getNode( this.node_name );
		if(!target_node) return;
		pos = target_node.transform.getPosition();
	}

	if(this.fixed_y)
		pos[1] = this._root.transform._position[1];
	this._root.transform.setPosition( pos );
}

LS.registerComponent(FollowNode);

/**
* FaceTo rotate a mesh to look at the camera or another object
* @class FaceTo
* @constructor
* @param {String} object to configure from
*/

function FaceTo(o)
{
	/*
	this.width = 10;
	this.height = 10;
	this.roll = 0;
	*/
	this.scale = 1;
	this.target = null;
	this.cylindrical = false;
	this.reverse = false;
}

FaceTo[&quot;@target&quot;] = {type:&#x27;node&#x27;};

FaceTo.prototype.onAddedToNode = function(node)
{
	LEvent.bind(node,&quot;computeVisibility&quot;,this.updateOrientation,this);
}

FaceTo.prototype.updateOrientation = function(e,info)
{
	if(!this._root) return;

	/*
	var dir = vec3.subtract( info.camera.getEye(), this._root.transform.getPosition(), vec3.create() );
	quat.lookAt( this._root.transform._rotation, dir, [0,1,0] );
	this._root.transform._dirty = true;
	*/

	var eye = null;
	
	if(this.target)
	{
		var node = Scene.getNode( this.target );
		if(!node)
			return;
		eye = node.transform.getPosition();
	}
	else
		eye = info.camera.getEye();
	var pos = this._root.transform.getPosition();
	var up = info.camera.getLocalVector([0,1,0]);
	if( this.cylindrical )
	{
		eye[1] = pos[1];
		up.set([0,1,0]);
	}
	if(!this.reverse)
		vec3.subtract(eye,pos,eye);
	this._root.transform.lookAt( pos, eye, up );
	this._root.transform.setScale( this.scale );
}

LS.registerComponent(FaceTo);

/**
* Realtime Reflective surface
* @class RealtimeReflector
* @constructor
* @param {String} object to configure from
*/


function RealtimeReflector(o)
{
	this.texture_size = 512;
	this.brightness_factor = 1.0;
	this.colorclip_factor = 0.0;
	this.clip_offset = 0.5; //to avoid ugly edges near clipping plane
	this.rt_name = &quot;&quot;;
	this.use_cubemap = false;
	this.use_mesh_info = false;
	this.refresh_rate = 1; //in frames
	this._rt = null;

	if(o)
		this.configure(o);
}

RealtimeReflector.prototype.onAddedToNode = function(node)
{
	if(!this._bind_onRenderRT)
		this._bind_onRenderRT = this.onRenderRT.bind(this);

	LEvent.bind(node,&quot;afterRenderShadows&quot;,this._bind_onRenderRT,this);
}


RealtimeReflector.prototype.onRemoveFromNode = function(node)
{
	LEvent.unbind(node,&quot;afterRenderShadows&quot;,this._bind_onRenderRT,this);
}


RealtimeReflector.prototype.onRenderRT = function(e,camera)
{
	if(!this._root) return;

	this.refresh_rate = this.refresh_rate &lt;&lt; 0;

	if( (Scene._frame == 0 || (Scene._frame % this.refresh_rate) != 0) &amp;&amp; this._rt)
		return;

	//texture
	if( !isPowerOfTwo(this.texture_size) )
		this.texture_size = 256;

	var texture_type = this.use_cubemap ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
	if(!this._rt || this._rt.width != this.texture_size || this._rt.texture_type != texture_type )
		this._rt = new Texture(this.texture_size,this.texture_size, { texture_type: texture_type });

	var plane_center = this._root.transform.getPositionGlobal();
	var plane_normal = this._root.transform.getTop();

	//use the first vertex and normal from a mesh
	if(this.use_mesh_info)
	{
		var mesh = this._root.getMesh();
		if(mesh)
		{
			plane_center = this._root.transform.transformPointGlobal( [mesh.vertices[0],mesh.vertices[1],mesh.vertices[2]] );
			plane_normal = this._root.transform.transformVectorGlobal( [mesh.normals[0],mesh.normals[1],mesh.normals[2]] );
		}
	}

	//camera
	var cam = new Camera( camera.serialize() );
	var visible = this._root.flags.visible;
	this._root.flags.visible = false;

	if( !this.use_cubemap )
	{
		cam.aspect = camera.aspect;
		cam.eye = geo.reflectPointInPlane( camera.eye, plane_center, plane_normal );
		cam.center = geo.reflectPointInPlane( camera.center, plane_center, plane_normal );
		cam.up = geo.reflectPointInPlane( camera.up, [0,0,0], plane_normal );

		//little offset
		vec3.add(plane_center, plane_center,vec3.scale(vec3.create(), plane_normal, -this.clip_offset));
		var clipping_plane = [plane_normal[0], plane_normal[1], plane_normal[2], vec3.dot(plane_center, plane_normal)  ];

		RenderPipeline.renderSceneMeshesToRT(cam,this._rt, {clipping_plane: clipping_plane, is_rt: true, is_reflection: true, brightness_factor: this.brightness_factor, colorclip_factor: this.colorclip_factor});
	}
	else
	{
		cam.eye = plane_center;
		RenderPipeline.renderSceneMeshesToRT(cam,this._rt, {is_rt: true, is_reflection: true, brightness_factor: this.brightness_factor, colorclip_factor: this.colorclip_factor});
	}

	this._root.flags.visible = visible;

	if(this.rt_name)
		ResourcesManager.registerResource(this.rt_name, this._rt);

	if(!this._root.material) return;
	
	this._root.material.setTexture(this.rt_name ? this.rt_name : this._rt, Material.ENVIRONMENT_TEXTURE, Material.COORDS_SCREEN);
}

LS.registerComponent(RealtimeReflector);


/**
* Rotator rotate a mesh over time
* @class Rotator
* @constructor
* @param {String} object to configure from
*/

function Rotator(o)
{
	this.speed = 10;
	this.axis = [0,1,0];
	this.local_space = true;
	this.swing = false;
	this.swing_amplitude = 45;
}

Rotator.prototype.onAddedToNode = function(node)
{
	LEvent.bind(node,&quot;update&quot;,this.onUpdate,this);
}


Rotator.prototype.onRemoveFromNode = function(node)
{
	LEvent.unbind(node,&quot;update&quot;,this.onUpdate,this);
}

Rotator.prototype.onUpdate = function(e,dt)
{
	if(!this._root) return;

	if(!this._default)
		this._default = this._root.transform.getRotation();

	vec3.normalize(this.axis,this.axis);

	if(this.swing)
	{
		var R = quat.setAxisAngle(quat.create(), this.axis, Math.sin( this.speed * Scene._global_time * 2 * Math.PI) * this.swing_amplitude * DEG2RAD );
		quat.multiply( this._root.transform._rotation, R, this._default);
		this._root.transform._dirty = true;
	}
	else
	{
		if(this.local_space)
			this._root.transform.rotateLocal(this.speed * dt,this.axis);
		else
			this._root.transform.rotate(this.speed * dt,this.axis);
	}
	LEvent.trigger(Scene,&quot;change&quot;);
}

LS.registerComponent(Rotator);

/**
* KnobComponent allows to rotate a mesh like a knob
* @class KnobComponent
* @constructor
* @param {String} object to configure from
*/


//
function KnobComponent(o)
{
	this.value = o.value || 0;
	this.delta = o.delta || 0.01; //pixels to value delta

	this.steps = o.steps || 0; //0 = continuous
	this.min_value = o.min_value || 0;
	this.max_value = o.max_value || 1;
	this.min_angle = o.min_angle || -120;
	this.max_angle = o.max_angle || 120;
	this.axis = o.axis || [0,0,1];

	if(o)
		this.configure(o);
}

/**
* Configure the component getting the info from the object
* @method configure
* @param {Object} object to configure from
*/

KnobComponent.prototype.configure = function(o)
{
	cloneObject(o, this);
}

/**
* Serialize this component)
* @method serialize
* @return {Object} object with the serialization info
*/

KnobComponent.prototype.serialize = function()
{
	 var o = cloneObject(this);
	 return o;
}

KnobComponent.prototype.onAddedToNode = function(node)
{
	node.interactive = true;
	LEvent.bind(node,&quot;mousemove&quot;,this.onmousemove,this);
	this.updateKnob();
}

KnobComponent.prototype.updateKnob = function() {
	if(!this._root) return;
	var f = this.value / (this.max_value - this.min_value)
	quat.setAxisAngle(this._root.transform._rotation,this.axis, (this.min_angle + (this.max_angle - this.min_angle) * f )* DEG2RAD);
	this._root.transform._dirty = true;
}

KnobComponent.prototype.onmousemove = function(e, mouse_event) { 
	this.value -= mouse_event.deltaY * this.delta;

	if(this.value &gt; this.max_value) this.value = this.max_value;
	else if(this.value &lt; this.min_value) this.value = this.min_value;

	this.updateKnob();

	LEvent.trigger( this, &quot;change&quot;, this.value);
	if(this._root)
		LEvent.trigger( this._root, &quot;knobChange&quot;, this.value);
};

LS.registerComponent(KnobComponent);


/**
* Camera controller
* @class FPSController
* @constructor
* @param {String} object to configure from
*/

function CameraController(o)
{
	this.speed = 10;
	this.rot_speed = 1;
	this.cam_type = &quot;orbit&quot;; //&quot;fps&quot;
	this._moving = vec3.fromValues(0,0,0);
	this.orbit_center = null;
}

CameraController.prototype.onAddedToNode = function(node)
{
	LEvent.bind(node,&quot;mousemove&quot;,this.onMouse,this);
	LEvent.bind(node,&quot;keydown&quot;,this.onKey,this);
	LEvent.bind(node,&quot;keyup&quot;,this.onKey,this);
	LEvent.bind(node,&quot;update&quot;,this.onUpdate,this);
}

CameraController.prototype.onUpdate = function(e)
{
	if(!this._root) return;

	if(this._root.transform)
	{
	}
	else if(this._root.camera)
	{
		var cam = this._root.camera;
		if(this.cam_type == &quot;fps&quot;)
		{
			if(this._moving[0] != 0 || this._moving[1] != 0 || this._moving[2] != 0)
			{
				var delta = cam.getLocalVector( this._moving );
				vec3.scale(delta, delta, this.speed * (this._move_fast?10:1));
				cam.move(delta);
				cam.updateMatrices();
			}
		}
	}
}

CameraController.prototype.onMouse = function(e)
{
	if(!this._root) return;
	
	if(e.dragging)
	{
		if(this._root.transform)
		{
		}
		else if(this._root.camera)
		{
			if(this.cam_type == &quot;fps&quot;)
			{
				var cam = this._root.camera;
				cam.rotate(-e.deltaX * this.rot_speed,[0,1,0]);
				cam.updateMatrices();
				var right = cam.getLocalVector([1,0,0]);
				cam.rotate(-e.deltaY * this.rot_speed,right);
				cam.updateMatrices();
			}
			else if(this.cam_type == &quot;orbit&quot;)
			{
				var cam = this._root.camera;

				if(e.ctrlKey)
				{
					var delta = cam.getLocalVector( [ this.speed * -e.deltaX * 0.1, this.speed * e.deltaY * 0.1, 0]);
					cam.move(delta);
					cam.updateMatrices();
				}
				else
				{
					cam.orbit(-e.deltaX * this.rot_speed,[0,1,0], this.orbit_center);
					if(e.shiftKey)
					{
						cam.updateMatrices();
						var right = cam.getLocalVector([1,0,0]);
						cam.orbit(-e.deltaY,right, this.orbit_center);
					}
					else
					{
						cam.orbitDistanceFactor(1 + e.deltaY * 0.01, this.orbit_center);
						cam.updateMatrices();
					}
				}
			}
		}
	}
	//LEvent.trigger(Scene,&quot;change&quot;);
}

CameraController.prototype.onKey = function(e)
{
	if(!this._root) return;
	//trace(e);
	if(e.keyCode == 87)
	{
		if(e.type == &quot;keydown&quot;)
			this._moving[2] = -1;
		else
			this._moving[2] = 0;
	}
	else if(e.keyCode == 83)
	{
		if(e.type == &quot;keydown&quot;)
			this._moving[2] = 1;
		else
			this._moving[2] = 0;
	}
	else if(e.keyCode == 65)
	{
		if(e.type == &quot;keydown&quot;)
			this._moving[0] = -1;
		else
			this._moving[0] = 0;
	}
	else if(e.keyCode == 68)
	{
		if(e.type == &quot;keydown&quot;)
			this._moving[0] = 1;
		else
			this._moving[0] = 0;
	}
	else if(e.keyCode == 16) //shift in windows chrome
	{
		if(e.type == &quot;keydown&quot;)
			this._move_fast = true;
		else
			this._move_fast = false;
	}

	//if(e.shiftKey) vec3.scale(this._moving,10);


	//LEvent.trigger(Scene,&quot;change&quot;);
}

LS.registerComponent(CameraController);



function ScriptComponent(o)
{
	this.code = &quot;&quot;;
	this._component = null;

	//this.component_name = &quot;&quot;;
	//this.register_component = false;
	this.configure(o);
	if(this.code)
		this.processCode();
}

ScriptComponent[&quot;@code&quot;] = {type:&#x27;script&#x27;};

ScriptComponent.valid_callbacks = [&quot;start&quot;,&quot;update&quot;];

ScriptComponent.prototype.processCode = function()
{
	var name = this.component_name || &quot;__last_component&quot;;
	var code = this.code;
	code = &quot;function &quot;+name+&quot;(component, node) {\n&quot; + code + &quot;\n&quot;;

	var extra_code = &quot;&quot;;
	for(var i in ScriptComponent.valid_callbacks)
		extra_code += &quot;	if(typeof(&quot;+ScriptComponent.valid_callbacks[i]+&quot;) != &#x27;undefined&#x27;) this.&quot;+ ScriptComponent.valid_callbacks[i] + &quot; = &quot;+ScriptComponent.valid_callbacks[i]+&quot;;\n&quot;;

	extra_code += &quot;\n}\nwindow.&quot;+name+&quot; = &quot;+name+&quot;;\n&quot;;

	//disabled feature
	var register = false &amp;&amp; this.component_name &amp;&amp; this.register_component;

	/* this creates a new component on the fly but seems dangerous
	if(register)
	{
		extra_code += name + &quot;.prototype.onStart = function() { if(this.start) this.start(); }\n&quot;;
		extra_code += name + &quot;.prototype.onUpdate = function(e,dt) { if(this.update) this.update(dt); }\n&quot;;
		extra_code += name + &quot;.prototype.onAddedToNode = function(node) { \
			LEvent.bind(Scene,&#x27;start&#x27;, this.onStart.bind(this) );\n\
			LEvent.bind(Scene,&#x27;update&#x27;, this.onUpdate.bind(this) );\n\
		};\n&quot;;
		extra_code += name + &quot;.prototype.onRemovedFromNode = function(node) { \
			LEvent.unbind(Scene,&#x27;start&#x27;, (function() { if(this.start) this.start(); }).bind(this) );\n\
			LEvent.unbind(Scene,&#x27;update&#x27;, (function(e,dt) { if(this.update) this.update(dt); }).bind(this) );\n\
		};\n&quot;;
	}
	*/

	code += extra_code;

	try
	{
		this._last_executed_code = code;
		//trace(code);
		eval(code);
		this._component_class = window[name];
		this._component = new this._component_class( this, this._root );
		//if(register) LS.registerComponent(this._component_class);
	}
	catch (err)
	{
		this._component_class = null;
		this._component = null;
		trace(&quot;Error in script\n&quot; + err);
		trace(this._last_executed_code );
	}
}


ScriptComponent.prototype.onAddedToNode = function(node)
{
	this._onStart_bind = this.onStart.bind(this);
	this._onUpdate_bind = this.onUpdate.bind(this);
	LEvent.bind(Scene,&quot;start&quot;, this._onStart_bind );
	LEvent.bind(Scene,&quot;update&quot;, this._onUpdate_bind );
}

ScriptComponent.prototype.onRemovedFromNode = function(node)
{
	LEvent.unbind(Scene,&quot;start&quot;, this._onStart_bind );
	LEvent.unbind(Scene,&quot;update&quot;, this._onUpdate_bind );
}

ScriptComponent.prototype.onStart = function()
{
	this.processCode();

	if(this._component &amp;&amp; this._component.start)
		this._component.start();
}

ScriptComponent.prototype.onUpdate = function(e,dt)
{
	if(this._component &amp;&amp; this._component.update)
		this._component.update(dt);
}


LS.registerComponent(ScriptComponent);
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
