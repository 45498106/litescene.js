<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/resourcesManager.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/LS.ComponentContainer.html">LS.ComponentContainer</a></li>
            
                <li><a href="../classes/LS.Components.Camera.html">LS.Components.Camera</a></li>
            
                <li><a href="../classes/LS.Components.FaceTo.html">LS.Components.FaceTo</a></li>
            
                <li><a href="../classes/LS.Components.FollowNode.html">LS.Components.FollowNode</a></li>
            
                <li><a href="../classes/LS.Components.FPSController.html">LS.Components.FPSController</a></li>
            
                <li><a href="../classes/LS.Components.FXGraphComponent.html">LS.Components.FXGraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.GeometricPrimitive.html">LS.Components.GeometricPrimitive</a></li>
            
                <li><a href="../classes/LS.Components.GraphComponent.html">LS.Components.GraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.KnobComponent.html">LS.Components.KnobComponent</a></li>
            
                <li><a href="../classes/LS.Components.Light.html">LS.Components.Light</a></li>
            
                <li><a href="../classes/LS.Components.RealtimeReflector.html">LS.Components.RealtimeReflector</a></li>
            
                <li><a href="../classes/LS.Components.Transform.html">LS.Components.Transform</a></li>
            
                <li><a href="../classes/LS.Context.html">LS.Context</a></li>
            
                <li><a href="../classes/LS.LS.html">LS.LS</a></li>
            
                <li><a href="../classes/LS.Material.html">LS.Material</a></li>
            
                <li><a href="../classes/LS.Octree.html">LS.Octree</a></li>
            
                <li><a href="../classes/LS.Renderer.html">LS.Renderer</a></li>
            
                <li><a href="../classes/LS.RenderInstance.html">LS.RenderInstance</a></li>
            
                <li><a href="../classes/LS.ResourcesManager.html">LS.ResourcesManager</a></li>
            
                <li><a href="../classes/LS.SceneNode.html">LS.SceneNode</a></li>
            
                <li><a href="../classes/LS.SceneTree.html">LS.SceneTree</a></li>
            
                <li><a href="../classes/Rotator.html">Rotator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/resourcesManager.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* Static class that contains all the resources loaded, parsed and ready to use.
* It also contains the parsers and methods in charge of processing them
*
* @class ResourcesManager
* @constructor
*/

// **** RESOURCES MANANGER *********************************************
// Resources should follow the text structure
// + id: if stored in remote server
// + resource_type: string (&quot;Mesh&quot;,&quot;Texture&quot;,...) or if omitted the classname will be used
// + filename: string
// + fullpath: the full path to reach the file on the server (folder + filename)
// + preview: img
// + toBinary: generates a binary version to store on the server
// + serialize: generates an stringifible object to store on the server

var ResourcesManager = {

	path: &quot;&quot;, //url to retrieve resources relative to the index.html
	ignore_cache: false, //change to true to ignore server cache
	free_data: false, //free all data once it has been uploaded to the VRAM

	resources: {}, //filename associated to a resource (texture,meshes,audio,script...)

	meshes: {}, //loadead meshes
	textures: {}, //loadead textures

	resources_being_loaded: {}, //resources waiting to be loaded
	num_resources_being_loaded: 0,
	MAX_TEXTURE_SIZE: 4096,

	formats: {&quot;js&quot;:&quot;text&quot;, &quot;json&quot;:&quot;json&quot;, &quot;xml&quot;:&quot;xml&quot;, &quot;jpg&quot;:&quot;image&quot;, &quot;png&quot;:&quot;image&quot;, &quot;bmp&quot;:&quot;image&quot; },
	resource_parsers: {}, //in charge or converting a file in a resource

	/**
	* Returns a string to append to any url that should use the browser cache (when updating server info)
	*
	* @method getNoCache
	* @param {Boolean} force force to return a nocache string ignoring the default configuration
	* @return {String} a string to attach to a url so the file wont be cached
	*/

	getNoCache: function(force) { return (!this.ignore_cache &amp;&amp; !force) ? &quot;&quot; : &quot;?nocache=&quot; + new Date().getTime() + Math.floor(Math.random() * 1000); },

	/**
	* Resets all the resources cached, so it frees the memory
	*
	* @method reset
	*/
	reset: function()
	{
		this.resources = {};
		this.meshes = {};
		this.textures = {};
	},

	/**
	* Returns the filename extension from an url
	*
	* @method getExtension
	* @param {String} url
	* @return {String} filename extension
	*/

	getExtension: function(url)
	{
		var point = url.lastIndexOf(&quot;.&quot;);
		if(point == -1) return &quot;&quot;;
		var question = url.lastIndexOf(&quot;?&quot;);
		question = (question == -1 ? url.length : (question - 1) ) - point;
		return url.substr(point+1,question).toLowerCase();
	},

	/**
	* Loads a generic resource, the type will be inferet from the extension
	*
	* @method load
	* @param {String} url where the resource is located (if its a relative url it depends on the path attribute)
	* @param {Object}[options={}] options to apply to the loaded image
	* @param {Function} [on_complete=null] callback when the resource is loaded and cached
	*/

	load: function(url, options, on_complete)
	{
		options = options || {};
		if(this.resources[url] != null)
		{
			if(on_complete)
				on_complete(this.resources[url]);
			return true;
		}

		//already being loaded
		if(this.resources_being_loaded[url] != null)
		{
			this.resources_being_loaded[url].push( {options: options, callback: on_complete} );
			return;
		}

		//load a new one
		this.resources_being_loaded[url] = [{options: options, callback: on_complete}];
		if(this.num_resources_being_loaded == 0)
			LEvent.trigger(ResourcesManager,&quot;start_loading_resources&quot;,url);
			//$(ResourcesManager).trigger(&quot;start_loading_resources&quot;, url);
		this.num_resources_being_loaded++;

		var pos = url.lastIndexOf(&quot;.&quot;)+1;
		var extension = url.substr(pos,url.length).toLowerCase();

		var full_url = &quot;&quot;;
		if(url.substr(0,7) == &quot;http://&quot;)
			full_url = url;
		else
		{
			if(options.local_repository)
				full_url = options.local_repository + &quot;/&quot; + url;
			else
				full_url = this.path + url;
		}

		if(options.force_local_url)
			full_url = url;

		var nocache = this.getNoCache();

		//ajax call
		var settings = {
			url: full_url + nocache,
			success: function(response){
				var res = ResourcesManager.processResource(url,response,options);
				ResourcesManager._resource_loaded_success(url,res); //triggers the on_complete
			},
			error: function(err) { 	ResourcesManager._resource_loaded_error(url,err); }
		};

		var extension = this.getExtension(url);
		var file_format = this.formats[ extension ];
		if(!file_format) file_format = &quot;text&quot;;
		settings.dataType = file_format;
		LS.request(settings); //ajax call
		return false;
	},

	/**
	* Process resource (most cases to upload it to the GPU)
	*
	* @method processResource
	* @param {String} url where the resource is located (if its a relative url it depends on the path attribute)
	* @param {*} data the data of the resource (could be string, arraybuffer, image... )
	* @param {Object}[options={}] options to apply to the loaded resource
	*/

	processResource: function(url, data, options)
	{
		var resource = null;
		if(data.object_type &amp;&amp; window[ data.object_type ] )
			resource = new window[ data.object_type ](data);

		if(resource)
		{
			if(!resource.fullpath)
				resource.fullpath = url;

			if(resource.getResources) //associate resources
			{
				ResourcesManager.loadResources( resource.getResources({}) );
			}

			this.registerResource(url,resource);
			return resource;
		}

		console.log(&quot;Unknown resource loaded&quot;);
	},
	
	/**
	* Loads a Mesh from url (in case it is already cached it skips the loading)
	*
	* @method loadMesh
	* @param {String} url where the mesh is located (if its a relative url it depends on the path attribute
	* @param {Object}[options={}] options to apply to the loaded image
	* @param {Function} [on_complete=null] callback when the mesh is loaded and cached
	*/

	loadMesh: function(url, options, on_complete)
	{
		options = options || {};

		if(this.meshes[url] != null)
		{
			if(on_complete)
				on_complete(this.meshes[url]);
			return true;
		}

		//already being loaded
		if(this.resources_being_loaded[url] != null)
		{
			this.resources_being_loaded[url].push( {options: options, callback: on_complete} );
			return;
		}

		//load a new one
		this.resources_being_loaded[url] = [{options: options, callback: on_complete}];
		if(this.num_resources_being_loaded == 0)
			LEvent.trigger(ResourcesManager,&quot;start_loading_resources&quot;,url);
			//$(ResourcesManager).trigger(&quot;start_loading_resources&quot;, url);
		this.num_resources_being_loaded++;

		var pos = url.lastIndexOf(&quot;.&quot;)+1;
		var extension = url.substr(pos,url.length).toLowerCase();

		var full_url = &quot;&quot;;
		if(url.substr(0,7) == &quot;http://&quot;)
			full_url = url;
		else
		{
			if(options.local_repository)
				full_url = options.local_repository + &quot;/&quot; + url;
			else
				full_url = this.path + url;
		}

		if(options.force_local_url)
			full_url = url;

		var nocache = this.getNoCache();

		//ajax call
		var settings = {
			url: full_url + nocache,
			success: function(response){
				var mesh = ResourcesManager.processMesh(url,response,options);
				ResourcesManager._resource_loaded_success(url,mesh);
			},
			error: function(err) { 	ResourcesManager._resource_loaded_error(url,err); }
		};

		var res_info = Parser.getResourceInfo(url);

		settings.dataType = &quot;text&quot;;
		if(res_info.format == Parser.JSON_FORMAT)
			settings.dataType = &#x27;json&#x27;;
		else if(res_info.format == Parser.XML_FORMAT)
			settings.dataType = &#x27;xml&#x27;;
		else if(res_info.format == Parser.BINARY_FORMAT)
			settings.dataType = &#x27;binary&#x27;;

		LS.request(settings);
		return false;
	},

	/**
	* Takes mesh raw data and creates a propper Mesh instance (uploads to GPU), caches it and launch the associated events
	*
	* @method processMesh
	* @param {String} filename the filename to process this raw data
	* @param {Object} data raw data of the mesh
	* @return {Object} the mesh instance
	*/

	processMesh: function(filename, data, options)
	{
		options = options || {};
		if(!gl) return null;

		//obtain info about the resource (extension, type of res, etc)
		var res_info = Parser.getResourceInfo(filename);

		var mesh_data = null;

		if(options.ignore_parser)
			mesh_data = data;
		else
			mesh_data = Parser.parse(filename, data, options);

		if(mesh_data == null)
		{
			throw (&quot;Error parsing mesh: &quot; + filename);
		}

		filename = options.name || filename; //used to rename AFTER parsing (otherwise parser can get the format wrong)

		var mesh = GL.Mesh.load(mesh_data);
		mesh.object_type = &quot;Mesh&quot;; //useful
		mesh.info = mesh_data.info; //save extra info like bounding
		mesh.metadata = {};
		mesh.filename = filename;
		mesh.generateMetadata(); //useful
		if(!mesh.bounding)
			mesh.computeBounding();

		if(this.free_data) //free buffers to reduce memory usage
			mesh.freeData();

		//save mesh in manager
		this.registerResource(filename,mesh);
		return mesh;
	},

	/**
	* Loads an Image from the internet and calls processImage (it the image is already loaded it skips the loading)
	*
	* @method loadImage
	* @param {String} url where the mesh is located (if its a relative url it depends on the path attribute
	* @param {Function} [on_complete=null] callback when the image is loaded, uploaded to GPU and cached
	* @param {Object}[options={}] options to apply to the loaded image
	*/

	loadImage: function(url, options, on_complete)
	{
		options = options || {};
		if(this.textures[url] != null) //reuse old version
		{
			if(on_complete)
				on_complete(this.textures[url]);
			return true;
		}

		//already being loaded
		if(this.resources_being_loaded[url] != null)
		{
			this.resources_being_loaded[url].push( {options: null, callback: on_complete} );
			return;
		}

		if(url[0] == &quot;:&quot;)
		{
			console.err(&quot;loadImage: cannot load filenames starting with &#x27;:&#x27;&quot;);
			return null;
		}

		this.resources_being_loaded[url] = [{options: null, callback: on_complete}];
		if(this.num_resources_being_loaded == 0)
			LEvent.trigger(ResourcesManager,&quot;start_loading_resources&quot;, url);
			//$(ResourcesManager).trigger(&quot;start_loading_resources&quot;, url);
		this.num_resources_being_loaded++;

		var full_url = &quot;&quot;;
		if(url.substr(0,7) == &quot;http://&quot; || url.substr(0,8) == &quot;https://&quot; || options.force_local_url)
			full_url = url;
		else
		{
			if(options.local_repository)
				full_url = options.local_repository + &quot;/&quot; + url;
			else
				full_url = this.path + url;
		}

		var nocache = this.getNoCache();

		//console.log(&quot;Processing image: &quot; + url);
		var res_info = Parser.getResourceInfo(url);
		if(res_info.type == Parser.IMAGE_DATA)
		{
			var img = new Image();
			img.type = &#x27;IMG&#x27;;
			img.onload = function()
			{
				this.onload = null;
				this.filename = url;
				if(options.flipY) this.flipY = options.flipY;
				var texture = ResourcesManager.processImage(url,this, options);
				ResourcesManager._resource_loaded_success(url,texture);
			}

			//img.onprogress = function(e) { console.log(&quot;Image: &quot; + url + &quot;    &quot; + e); }
			img.onerror = function(err) { ResourcesManager._resource_loaded_error(url,err); }

			img.src = full_url + nocache;
		}
		else if (res_info.type == Parser.NONATIVE_IMAGE_DATA)
		{
			var full_url = this.path + url;
			var nocache = this.getNoCache();

			LS.request({
				url: full_url + nocache,
				dataType: &quot;binary&quot;,
				success: function(response){
					var img = Parser.parse(url, response);
					var texture = null;
					if (img) {
						texture = ResourcesManager.processImage(url,img, options);
						ResourcesManager._resource_loaded_success(url,texture);
					}
					delete ResourcesManager.resources_being_loaded[url];
				},
				error: function(err) { ResourcesManager._resource_loaded_error(url,err); }
			});
		}
		else
			ResourcesManager._resource_loaded_error(url,&quot;Wront file format&quot;);

		return false;
	},

	/**
	* Takes image raw data and creates a propper Texture instance, caches it and launch the associated events
	*
	* @method processImage
	* @param {String} filename the filename to process this raw data
	* @param {Object} data raw data of the image (could be an Image tag or a Canvas tag)
	* @param {Object}[options={}] options to process the data
	* @return {Object} the Texture instance
	*/

	processImage: function(filename, img, options)
	{
		options = options || {};
		if(!gl) return null;

		if (img.width &gt; this.MAX_TEXTURE_SIZE)
		{
			console.log(&quot;too big, max is &quot; + this.MAX_TEXTURE_SIZE);
			return null;
		}
		/*
		else if (img.width != img.height)
		{
			if(img.width != (img.height / 6) &amp;&amp; (img.height % 6) != 0)
			{
				console.log(&quot;Warning: Image must be square (same width and height)&quot;);
				//return null;
			}
		}
		else if ( ((Math.log(img.width) / Math.log(2)) % 1) != 0 || ((Math.log(img.height) / Math.log(2)) % 1) != 0)
		{
			console.log(&quot;Image dimensions must be power of two (64,128,256,512)&quot;);
			return null;
		}
		*/

		if(img.constructor == Texture)
		{
			var texture = img;
			texture.filename = filename;
			this.registerResource(filename, texture);
			console.log(&quot;DDS created&quot;);
		}
		else if(img.width == (img.height / 6)) //cubemap
		{
			var texture = Texture.cubemapFromImage(img, { wrapS: gl.MIRROR, wrapT: gl.MIRROR, magFilter: gl.LINEAR, minFilter: gl.LINEAR_MIPMAP_LINEAR });
			texture.img = img;
			texture.filename = filename;
			this.registerResource(filename, texture);
			console.log(&quot;Cubemap created&quot;);
		}
		else //regular texture
		{
			var default_mag_filter = gl.LINEAR;
			//var default_min_filter = img.width == img.height ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR;
			var default_min_filter = gl.LINEAR_MIPMAP_LINEAR;
			if( !isPowerOfTwo(img.width) || !isPowerOfTwo(img.height) )
				default_min_filter = gl.LINEAR;
			var texture = null;

			//from TGAs...
			if(img.pixels)
				texture = GL.Texture.fromMemory(img.width, img.height, img.pixels, { format: (img.bpp == 24 ? gl.RGB : gl.RGBA), flipY: img.flipY, wrapS: gl.REPEAT, wrapT: gl.REPEAT, magFilter: default_mag_filter, minFilter: default_min_filter });
			else //RGBA because particles have alpha (PNGs)
				texture = GL.Texture.fromImage(img, { format: gl.RGBA, wrapS: gl.REPEAT, wrapT: gl.REPEAT, magFilter: default_mag_filter, minFilter: default_min_filter, flipY: img.flipY });
			texture.img = img;
			texture.filename = filename;
			this.registerResource(filename, texture);
		}

		texture.filename = filename;
		texture.generateMetadata(); //useful

		LEvent.trigger(Scene,&quot;change&quot;);
		return texture;
	},

	processScene: function(filename, data, options)
	{
		var scene_data = Parser.parse(filename, data, options);

		//register meshes
		if(scene_data.meshes)
		{
			for (var i in scene_data.meshes)
			{
				var mesh_data = scene_data.meshes[i];
				var mesh = GL.Mesh.load(mesh_data);
				ResourcesManager.registerResource(i,mesh);
			}
		}

		var scene = new LS.SceneTree();
		scene.configure(scene_data);

		//load resources
		scene.loadResources();

		return scene;
	},

	/**
	* Loads all the resources in the Object (it uses an object to store not only the filename but also the type)
	*
	* @method loadResources
	* @param {Object} resources contains all the resources, associated with its type
	* @param {Object}[options={}] options to apply to the loaded resources
	*/

	loadResources: function(res, options )
	{
		for(var i in res)
		{
			if( typeof(i) != &quot;string&quot; || i[0] == &quot;:&quot; )
				continue;
		
			if(res[i] == Mesh)
				this.loadMesh( i, options );
			else if(res[i] == Texture)
				this.loadImage( i, options );
			else
				this.load(i, options );
		}
	},

	computeImageMetadata: function(texture)
	{
		var metadata = { width: texture.width, height: texture.height };
		return metadata;
	},

	/**
	* Stores the resource in the manager containers
	*
	* @method registerResource
	* @param {String} filename 
	* @param {Object} resource 
	*/

	registerResource: function(filename,res)
	{
		if(!res.object_type)
			res.object_type = getObjectClassName(res);
		var type = res.object_type;
		if(type == &quot;Mesh&quot;)
			this.meshes[filename] = res;
		else if(type == &quot;Texture&quot;)
			this.textures[filename] = res;
		else if(type == &quot;Material&quot;)
			Scene.materials[filename] = res;
		else
			console.log(&quot;Unknown res type: &quot; + type);

		this.resources[filename] = res;
		LEvent.trigger(this,&quot;resource_loaded&quot;, res);
	},

	/**
	* returns a mesh resource if it is loaded
	*
	* @method getMesh
	* @param {String} filename 
	* @return {Mesh}
	*/

	getMesh: function(name) {
		if(name != null) return this.meshes[name];
		return null;
	},

	/**
	* returns a texture resource if it is loaded
	*
	* @method getTexture
	* @param {String} filename 
	* @return {Texture} 
	*/

	getTexture: function(name) {
		if(name != null) return this.textures[name];
		return null;
	},

	//*************************************

	//Called after a resource has been loaded successfully and processed
	_resource_loaded_success: function(url,res)
	{
		if( LS.ResourcesManager.debug )
			console.log(&quot;RES: &quot; + url + &quot; ---&gt; &quot; + ResourcesManager.num_resources_being_loaded);
		for(var i in ResourcesManager.resources_being_loaded[url])
		{
			if(ResourcesManager.resources_being_loaded[url][i].callback != null)
				ResourcesManager.resources_being_loaded[url][i].callback(res);
		}
		if(ResourcesManager.resources_being_loaded[url])
		{
			delete ResourcesManager.resources_being_loaded[url];
			ResourcesManager.num_resources_being_loaded--;
			if( ResourcesManager.num_resources_being_loaded == 0)
			{
				LEvent.trigger( ResourcesManager, &quot;end_loading_resources&quot;);
			}
		}
	},

	_resource_loaded_error: function(url, error)
	{
		console.log(&quot;Error loading &quot; + url);
		delete ResourcesManager.resources_being_loaded[url];
		LEvent.trigger( ResourcesManager, &quot;resource_not_found&quot;, url);
		ResourcesManager.num_resources_being_loaded--;
		if( ResourcesManager.num_resources_being_loaded == 0 )
			LEvent.trigger( ResourcesManager, &quot;end_loading_resources&quot;);
			//$(ResourcesManager).trigger(&quot;end_loading_resources&quot;);
	},

	//NOT TESTED: to load script asyncronously, not finished. similar to require.js
	require: function(files, on_complete)
	{
		if(typeof(files) == &quot;string&quot;)
			files = [files];

		//store for the callback
		var last = files[ files.length - 1];
		if(on_complete)
		{
			if(!ResourcesManager._waiting_callbacks[ last ])
				ResourcesManager._waiting_callbacks[ last ] = [on_complete];
			else
				ResourcesManager._waiting_callbacks[ last ].push(on_complete);
		}
		require_file(files);

		function require_file(files)
		{
			//avoid require twice a file
			var url = files.shift(1); 
			while( ResourcesManager._required_files[url] &amp;&amp; url )
				url = files.shift(1);

			ResourcesManager._required_files[url] = true;

			LS.request({
				url: url,
				success: function(response)
				{
					eval(response);
					if( ResourcesManager._waiting_callbacks[ url ] )
						for(var i in ResourcesManager._waiting_callbacks[ url ])
							ResourcesManager._waiting_callbacks[ url ][i]();
					require_file(files);
				}
			});
		}
	},
	_required_files: {},
	_waiting_callbacks: {}
};

LS.ResourcesManager = ResourcesManager;
LS.RM = ResourcesManager;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
