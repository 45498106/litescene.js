<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/utils/octree.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/LS.ComponentContainer.html">LS.ComponentContainer</a></li>
            
                <li><a href="../classes/LS.Components.Camera.html">LS.Components.Camera</a></li>
            
                <li><a href="../classes/LS.Components.CameraController.html">LS.Components.CameraController</a></li>
            
                <li><a href="../classes/LS.Components.FaceTo.html">LS.Components.FaceTo</a></li>
            
                <li><a href="../classes/LS.Components.FollowNode.html">LS.Components.FollowNode</a></li>
            
                <li><a href="../classes/LS.Components.FXGraphComponent.html">LS.Components.FXGraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.GeometricPrimitive.html">LS.Components.GeometricPrimitive</a></li>
            
                <li><a href="../classes/LS.Components.GraphComponent.html">LS.Components.GraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.KnobComponent.html">LS.Components.KnobComponent</a></li>
            
                <li><a href="../classes/LS.Components.Light.html">LS.Components.Light</a></li>
            
                <li><a href="../classes/LS.Components.NodeManipulator.html">LS.Components.NodeManipulator</a></li>
            
                <li><a href="../classes/LS.Components.OculusController.html">LS.Components.OculusController</a></li>
            
                <li><a href="../classes/LS.Components.RealtimeReflector.html">LS.Components.RealtimeReflector</a></li>
            
                <li><a href="../classes/LS.Components.Spherize.html">LS.Components.Spherize</a></li>
            
                <li><a href="../classes/LS.Components.Transform.html">LS.Components.Transform</a></li>
            
                <li><a href="../classes/LS.Context.html">LS.Context</a></li>
            
                <li><a href="../classes/LS.LS.html">LS.LS</a></li>
            
                <li><a href="../classes/LS.Material.html">LS.Material</a></li>
            
                <li><a href="../classes/LS.Octree.html">LS.Octree</a></li>
            
                <li><a href="../classes/LS.Renderer.html">LS.Renderer</a></li>
            
                <li><a href="../classes/LS.RenderInstance.html">LS.RenderInstance</a></li>
            
                <li><a href="../classes/LS.ResourcesManager.html">LS.ResourcesManager</a></li>
            
                <li><a href="../classes/LS.SceneNode.html">LS.SceneNode</a></li>
            
                <li><a href="../classes/LS.SceneTree.html">LS.SceneTree</a></li>
            
                <li><a href="../classes/Rotator.html">Rotator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/utils/octree.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
*   Octree generator for fast ray triangle collision with meshes
*	Dependencies: glmatrix.js (for vector and matrix operations)
* @class Octree
* @constructor
* @param {Mesh} mesh object containing vertices buffer (indices buffer optional)
*/

function HitTest(t, hit, normal) {
  this.t = arguments.length ? t : Number.MAX_VALUE;
  this.hit = hit;
  this.normal = normal;
}

HitTest.prototype = {
  mergeWith: function(other) {
    if (other.t &gt; 0 &amp;&amp; other.t &lt; this.t) {
      this.t = other.t;
      this.hit = other.hit;
      this.normal = other.normal;
    }
  }
};


function Octree(mesh)
{
	this.root = null;
	this.total_depth = 0;
	this.total_nodes = 0;
	if(mesh)
	{
		this.buildFromMesh(mesh);
		this.total_nodes = this.trim();
	}
}

Octree.prototype = {
	MAX_OCTREE_TRIANGLES: 500,
	MAX_OCTREE_DEPTH: 8,
	OCTREE_MARGIN: 10,

	buildFromMesh: function(mesh)
	{
		this.total_depth = 0;
		this.total_nodes = 0;

		var vertices = mesh.vertices;
		var triangles = mesh.triangles;

		var root = this.computeAABB(vertices);
		this.root = root;
		this.total_nodes = 1;

		root.min = [root.min[0] - this.OCTREE_MARGIN, root.min[1] - this.OCTREE_MARGIN, root.min[2] - this.OCTREE_MARGIN];
		root.max = [root.max[0] + this.OCTREE_MARGIN*0.9, root.max[1] + this.OCTREE_MARGIN*0.9, root.max[2] + this.OCTREE_MARGIN*0.9];
		root.faces = [];
		root.inside = 0;

		//indexed
		if(triangles)
		{
			for(var i = 0; i &lt; triangles.length; i+=3)
			{
				var face = new Float32Array([vertices[triangles[i]*3], vertices[triangles[i]*3+1],vertices[triangles[i]*3+2],
							vertices[triangles[i+1]*3], vertices[triangles[i+1]*3+1],vertices[triangles[i+1]*3+2],
							vertices[triangles[i+2]*3], vertices[triangles[i+2]*3+1],vertices[triangles[i+2]*3+2]]);
				this.addToNode(face,root,0);
				//if(i%3000 == 0) trace(&quot;Tris: &quot; + i);
			}
		}
		else
		{
			for(var i = 0; i &lt; vertices.length; i+=9)
			{
				var face = new Float32Array( vertices.subarray(i,i+9) );
				this.addToNode(face,root,0);
				//if(i%3000 == 0) trace(&quot;Tris: &quot; + i);
			}
		}

		return root;
	},

	addToNode: function(face,node, depth)
	{
		node.inside += 1;

		//has children
		if(node.c)
		{
			var aabb = this.computeAABB(face);
			var added = false;
			for(var i in node.c)
			{
				var child = node.c[i];
				if (this.isInsideAABB(aabb,child))
				{
					this.addToNode(face,child, depth+1);
					added = true;
					break;
				}
			}
			if(!added)
			{
				if(node.faces == null) node.faces = [];
				node.faces.push(face);
			}
		}
		else //add till full, then split
		{
			if(node.faces == null) node.faces = [];
			node.faces.push(face);

			//split
			if(node.faces.length &gt; this.MAX_OCTREE_TRIANGLES &amp;&amp; depth &lt; this.MAX_OCTREE_DEPTH)
			{
				this.splitNode(node);
				if(this.total_depth &lt; depth + 1)
					this.total_depth = depth + 1;

				var faces = node.faces.concat();
				node.faces = null;

				//redistribute all nodes
				for(var i in faces)
				{
					var face = faces[i];
					var aabb = this.computeAABB(face);
					var added = false;
					for(var j in node.c)
					{
						var child = node.c[j];
						if (this.isInsideAABB(aabb,child))
						{
							this.addToNode(face,child, depth+1);
							added = true;
							break;
						}
					}
					if (!added)
					{
						if(node.faces == null) node.faces = [];
						node.faces.push(face);
					}
				}
			}
		}
	},

	octree_pos_ref: [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]],

	splitNode: function(node)
	{
		node.c = [];
		var half = [(node.max[0] - node.min[0]) * 0.5, (node.max[1] - node.min[1]) * 0.5, (node.max[2] - node.min[2]) * 0.5];

		for(var i in this.octree_pos_ref)
		{
			var ref = this.octree_pos_ref[i];

			var newnode = {};
			this.total_nodes += 1;

			newnode.min = [ node.min[0] + half[0] * ref[0],  node.min[1] + half[1] * ref[1],  node.min[2] + half[2] * ref[2]];
			newnode.max = [newnode.min[0] + half[0], newnode.min[1] + half[1], newnode.min[2] + half[2]];
			newnode.faces = null;
			newnode.inside = 0;
			node.c.push(newnode);
		}
	},

	isInsideAABB: function(a,b)
	{
		if(a.min[0] &lt; b.min[0] || a.min[1] &lt; b.min[1] || a.min[2] &lt; b.min[2] ||
			a.max[0] &gt; b.max[0] || a.max[1] &gt; b.max[1] || a.max[2] &gt; b.max[2])
			return false;
		return true;
	},

	computeAABB: function(vertices)
	{
		var min = [ vertices[0], vertices[1], vertices[2] ];
		var max = [ vertices[0], vertices[1], vertices[2] ];

		for(var i = 0; i &lt; vertices.length; i+=3)
		{
			for(var j = 0; j &lt; 3; j++)
			{
				if(min[j] &gt; vertices[i+j]) 
					min[j] = vertices[i+j];
				if(max[j] &lt; vertices[i+j]) 
					max[j] = vertices[i+j];
			}
		}

		var r = {min: min, max: max};
		return r;
	},

	trim: function(node)
	{
		node = node || this.root;
		if(!node.c)
			return 1;

		var num = 1;
		var valid = [];
		for(var i in node.c)
		{
			if(node.c[i].inside)
			{
				valid.push(node.c[i]);
				num += this.trim(node.c[i]);
			}
		}
		node.c = valid;
		return num;
	},

	hitTestBox: function(origin, ray, box_min, box_max) {
		var tMin = vec3.subtract( vec3.create(), box_min, origin );
		var tMax = vec3.subtract( vec3.create(), box_max, origin );
		
		if(	vec3.maxValue(tMin) &lt; 0 &amp;&amp; vec3.minValue(tMax) &gt; 0)
			return new HitTest(0,origin,ray);

		vec3.multiply(tMin, tMin, [1/ray[0],1/ray[1],1/ray[2]]);
		vec3.multiply(tMax, tMax, [1/ray[0],1/ray[1],1/ray[2]]);
		var t1 = vec3.min(vec3.create(), tMin, tMax);
		var t2 = vec3.max(vec3.create(), tMin, tMax);
		var tNear = vec3.maxValue(t1);
		var tFar = vec3.minValue(t2);

		if (tNear &gt; 0 &amp;&amp; tNear &lt; tFar) {
			var epsilon = 1.0e-6, hit = vec3.add( vec3.create(), vec3.scale(vec3.create(), ray, tNear ), origin);
			vec3.add(box_min, box_min,[epsilon,epsilon,epsilon]);
			vec3.subtract(box_min, box_min,[epsilon,epsilon,epsilon]);
			return new HitTest(tNear, hit, vec3.create([
			  (hit[0] &gt; box_max[0]) - (hit[0] &lt; box_min[0]),
			  (hit[1] &gt; box_max[1]) - (hit[1] &lt; box_min[1]),
			  (hit[2] &gt; box_max[2]) - (hit[2] &lt; box_min[2]) ]));
		}

		return null;
	},

	tested_boxes: 0,
	tested_triangles: 0,


	/**
	* Uploads a set of uniforms to the Shader
	* @method testRay
	* @param {vec3} start ray start position
	* @param {vec3} direction ray direction position
	* @param {number} dist_min
	* @param {number} dist_max
	* @return {HitTest} object containing pos and normal
	*/
	testRay: function(start, direction, dist_min, dist_max)
	{
		start = vec3.clone(start);
		direction = vec3.clone(direction);
		//direction = direction.unit();
		Octree.prototype.tested_boxes = 0;
		Octree.prototype.tested_triangles = 0;

		if(!this.root)
		{
			throw(&quot;Error: octree not build&quot;);
		}

		window.hitTestBox = this.hitTestBox;
		window.hitTestTriangle = this.hitTestTriangle;
		window.testRayInNode = Octree.prototype.testRayInNode;

		var test = hitTestBox( start, direction, vec3.clone(this.root.min), vec3.clone(this.root.max) );
		if(!test) //no collision with mesh bounding box
			return null;

		var test = testRayInNode(this.root,start,direction);
		if(test != null)
		{
			var pos = vec3.scale( vec3.create(), direction, test.t );
			vec3.add( pos, pos, start );
			test.pos = pos;
			return test;
		}

		delete window[&quot;hitTestBox&quot;];
		delete window[&quot;hitTestTriangle&quot;];
		delete window[&quot;testRayInNode&quot;];

		return null;
	},

	testRayInNode: function(node, start, direction)
	{
		var test = null;
		var prev_test = null;
		Octree.prototype.tested_boxes += 1;

		//test faces
		if(node.faces)
			for(var i in node.faces)
			{
				var face = node.faces[i];
				
				Octree.prototype.tested_triangles += 1;
				test = hitTestTriangle(start,direction, vec3.fromValues(face[0],face[1],face[2]) , vec3.fromValues(face[3],face[4],face[5]), vec3.fromValues(face[6],face[7],face[8]) );
				if (test==null)
					continue;
				if(prev_test)
					prev_test.mergeWith(test);
				else
					prev_test = test;
			}

		//test children nodes faces
		var child;
		if(node.c)
			for(var i in node.c)
			{
				child = node.c[i];
				//test with node box
				test = hitTestBox( start, direction, vec3.clone(child.min), vec3.clone(child.max) );
				if( test == null )
					continue;

				//nodebox behind current collision, then ignore node
				if(prev_test &amp;&amp; test.t &gt; prev_test.t)
					continue;

				//test collision with node
				test = testRayInNode(child, start, direction);
				if(test == null)
					continue;

				if(prev_test)
					prev_test.mergeWith(test);
				else
					prev_test = test;
			}

		return prev_test;
	},

	hitTestTriangle: function(origin, ray, a, b, c) {
		var ab = vec3.subtract( vec3.create(), b,a );
		var ac = vec3.subtract( vec3.create(), c,a );
		var normal = vec3.cross( vec3.create(), ab, ac );
		vec3.normalize( normal, normal );
		if( vec3.dot(normal,ray) &gt; 0) return; //ignore backface

		var t = vec3.dot(normal, vec3.subtract( vec3.create(), a, origin )) / vec3.dot(normal,ray);

	  if (t &gt; 0) {
		var hit = vec3.scale(vec3.create(), ray, t);
		vec3.add(hit, hit, origin);
		var toHit = vec3.subtract( vec3.create(), hit,a );
		var dot00 = vec3.dot(ac,ac);
		var dot01 = vec3.dot(ac,ab);
		var dot02 = vec3.dot(ac,toHit);
		var dot11 = vec3.dot(ab,ab);
		var dot12 = vec3.dot(ab,toHit);
		var divide = dot00 * dot11 - dot01 * dot01;
		var u = (dot11 * dot02 - dot01 * dot12) / divide;
		var v = (dot00 * dot12 - dot01 * dot02) / divide;
		if (u &gt;= 0 &amp;&amp; v &gt;= 0 &amp;&amp; u + v &lt;= 1) return new HitTest(t, hit, normal);
	  }

	  return null;
	}
};

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
