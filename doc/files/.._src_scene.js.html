<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/scene.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/LS.Animation.html">LS.Animation</a></li>
            
                <li><a href="../classes/LS.Animation.Track.html">LS.Animation.Track</a></li>
            
                <li><a href="../classes/LS.ComponentContainer.html">LS.ComponentContainer</a></li>
            
                <li><a href="../classes/LS.Components.Camera.html">LS.Components.Camera</a></li>
            
                <li><a href="../classes/LS.Components.CameraController.html">LS.Components.CameraController</a></li>
            
                <li><a href="../classes/LS.Components.CameraFX.html">LS.Components.CameraFX</a></li>
            
                <li><a href="../classes/LS.Components.FaceTo.html">LS.Components.FaceTo</a></li>
            
                <li><a href="../classes/LS.Components.FollowNode.html">LS.Components.FollowNode</a></li>
            
                <li><a href="../classes/LS.Components.FXGraphComponent.html">LS.Components.FXGraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.GeometricPrimitive.html">LS.Components.GeometricPrimitive</a></li>
            
                <li><a href="../classes/LS.Components.GraphComponent.html">LS.Components.GraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.KnobComponent.html">LS.Components.KnobComponent</a></li>
            
                <li><a href="../classes/LS.Components.Light.html">LS.Components.Light</a></li>
            
                <li><a href="../classes/LS.Components.LightFX.html">LS.Components.LightFX</a></li>
            
                <li><a href="../classes/LS.Components.NodeManipulator.html">LS.Components.NodeManipulator</a></li>
            
                <li><a href="../classes/LS.Components.OculusController.html">LS.Components.OculusController</a></li>
            
                <li><a href="../classes/LS.Components.PlayAnimation.html">LS.Components.PlayAnimation</a></li>
            
                <li><a href="../classes/LS.Components.RealtimeReflector.html">LS.Components.RealtimeReflector</a></li>
            
                <li><a href="../classes/LS.Components.Spherize.html">LS.Components.Spherize</a></li>
            
                <li><a href="../classes/LS.Components.Transform.html">LS.Components.Transform</a></li>
            
                <li><a href="../classes/LS.CompositePattern.html">LS.CompositePattern</a></li>
            
                <li><a href="../classes/LS.Context.html">LS.Context</a></li>
            
                <li><a href="../classes/LS.LS.html">LS.LS</a></li>
            
                <li><a href="../classes/LS.LScript.html">LS.LScript</a></li>
            
                <li><a href="../classes/LS.Material.html">LS.Material</a></li>
            
                <li><a href="../classes/LS.Physics.html">LS.Physics</a></li>
            
                <li><a href="../classes/LS.PhysicsInstance.html">LS.PhysicsInstance</a></li>
            
                <li><a href="../classes/LS.Prefab.html">LS.Prefab</a></li>
            
                <li><a href="../classes/LS.Renderer.html">LS.Renderer</a></li>
            
                <li><a href="../classes/LS.RenderInstance.html">LS.RenderInstance</a></li>
            
                <li><a href="../classes/LS.RenderOptions.html">LS.RenderOptions</a></li>
            
                <li><a href="../classes/LS.ResourcesManager.html">LS.ResourcesManager</a></li>
            
                <li><a href="../classes/LS.SceneNode.html">LS.SceneNode</a></li>
            
                <li><a href="../classes/LS.SceneTree.html">LS.SceneTree</a></li>
            
                <li><a href="../classes/LS.StandardMaterial.html">LS.StandardMaterial</a></li>
            
                <li><a href="../classes/LS.WBin.html">LS.WBin</a></li>
            
                <li><a href="../classes/Rotator.html">Rotator</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/scene.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
/**
* The SceneTree contains all the info about the Scene and nodes
*
* @class SceneTree
* @constructor
*/

function SceneTree()
{
	this._uid = LS.generateUId();

	this._root = new LS.SceneNode(&quot;root&quot;);
	this._root.removeAllComponents();
	this._root._is_root  = true;
	this._root._in_tree = this;
	this._nodes = [ this._root ];
	this._nodes_by_id = {&quot;root&quot;:this._root};

	LEvent.bind(this,&quot;treeItemAdded&quot;, this.onNodeAdded.bind(this));
	LEvent.bind(this,&quot;treeItemRemoved&quot;, this.onNodeRemoved.bind(this));


	this.init();
}

//globals
SceneTree.DEFAULT_BACKGROUND_COLOR = new Float32Array([0,0,0,1]);
SceneTree.DEFAULT_AMBIENT_COLOR = vec3.fromValues(0.2, 0.2, 0.2);

Object.defineProperty( SceneTree.prototype, &quot;root&quot;, {
	enumerable: true,
	get: function() {
		return this._root;
	},
	set: function(v) {
		throw(&quot;Root node cannot be replaced&quot;);
	}
});

//methods

/**
* This initializes the content of the scene.
* Call it to clear the scene content
*
* @method init
* @return {Boolean} Returns true on success
*/
SceneTree.prototype.init = function()
{
	this.id = &quot;&quot;;
	//this.materials = {}; //shared materials cache: moved to LS.RM.resources
	this.local_repository = null;

	this._root.removeAllComponents();
	this._nodes = [ this._root ];
	this._nodes_by_id = {&quot;root&quot;:this._root};
	this.rt_cameras = [];

	//this._components = []; //remove all components

	this._root.addComponent( new Camera() );
	this.current_camera = this._root.camera;

	this._root.addComponent( new Light({ position: vec3.fromValues(100,100,100), target: vec3.fromValues(0,0,0) }) );

	this.ambient_color = new Float32Array( SceneTree.DEFAULT_AMBIENT_COLOR );
	this.background_color = new Float32Array( SceneTree.DEFAULT_BACKGROUND_COLOR );
	this.textures = {};

	this._frame = 0;
	this._last_collect_frame = -1; //force collect
	this._time = 0;
	this._global_time = 0; //in seconds
	this._start_time = 0; //in seconds
	this._last_dt = 1/60; //in seconds
	this._must_redraw = true;

	if(this.selected_node) delete this.selected_node;

	this.extra = {};

	this._renderer = LS.Renderer;
}

/**
* Clears the scene using the init function
* and trigger a &quot;clear&quot; LEvent
*
* @method clear
*/
SceneTree.prototype.clear = function()
{
	//remove all nodes to ensure no lose callbacks are left
	while(this._root._children &amp;&amp; this._root._children.length)
		this._root.removeChild(this._root._children[0]);

	//remove scene components
	this._root.processActionInComponents(&quot;onRemovedFromNode&quot;,this); //send to components
	this._root.processActionInComponents(&quot;onRemovedFromScene&quot;,this); //send to components

	this.init();
	LEvent.trigger(this,&quot;clear&quot;);
	LEvent.trigger(this,&quot;change&quot;);
}

/**
* Configure the Scene using an object (the object can be obtained from the function serialize)
* Inserts the nodes, configure them, and change the parameters
*
* @method configure
* @param {Object} scene_info the object containing all the info about the nodes and config of the scene
*/
SceneTree.prototype.configure = function(scene_info)
{
	this._root.removeAllComponents(); //remove light and camera

	//this._components = [];
	//this.camera = this.light = null; //legacy

	if(scene_info.object_type != &quot;SceneTree&quot;)
		trace(&quot;Warning: object set to scene doesnt look like a propper one.&quot;);

	if(scene_info.local_repository)
		this.local_repository = scene_info.local_repository;
	//parse basics
	if(scene_info.background_color)
		this.background_color.set(scene_info.background_color);
	if(scene_info.ambient_color)
		this.ambient_color.set(scene_info.ambient_color);

	if(scene_info.textures)
		this.textures = scene_info.textures;

	//extra info that the user wanted to save (comments, etc)
	if(scene_info.extra)
		this.extra = scene_info.extra;

	if(scene_info.root)
		this.root.configure( scene_info.root );

	//legacy
	if(scene_info.nodes)
		this.root.configure( { children: scene_info.nodes } );

	//parse materials
	/*
	if(scene_info.materials)
		for(var i in scene_info.materials)
			this.materials[ i ] = new Material( scene_info.materials[i] );
	*/

	//legacy
	if(scene_info.components)
		this._root.configureComponents(scene_info);

	// LEGACY...
	if(scene_info.camera)
	{
		if(this._root.camera)
			this._root.camera.configure( scene_info.camera );
		else
			this._root.addComponent( new Camera( scene_info.camera ) );
	}

	if(scene_info.light)
	{
		if(this._root.light)
			this._root.light.configure( scene_info.light );
		else
			this._root.addComponent( new Light(scene_info.light) );
	}
	else if(scene_info.hasOwnProperty(&quot;light&quot;)) //light is null
	{
		//skip default light
		if(this._root.light)
		{
			this._root.removeComponent( this._root.light );
			this._root.light = null;
		}
	}

	//if(scene_info.animations)
	//	this._root.animations = scene_info.animations;

	LEvent.trigger(this,&quot;configure&quot;,scene_info);
	LEvent.trigger(this,&quot;change&quot;);
}

/**
* Creates and object containing all the info about the scene and nodes.
* The oposite of configure.
* It calls the serialize method in every node
*
* @method serialize
* @return {Object} return a JS Object with all the scene info
*/

SceneTree.prototype.serialize = function()
{
	var o = {};

	o.object_type = getObjectClassName(this);

	//legacy
	o.local_repository = this.local_repository;

	//this is ugly but scenes can have also some rendering properties
	o.ambient_color = toArray( this.ambient_color );
	o.background_color = toArray( this.background_color ); //to non-typed
	o.textures = cloneObject(this.textures);

	//o.nodes = [];
	o.extra = this.extra || {};

	//add nodes
	o.root = this.root.serialize();

	//add shared materials
	/*
	if(this.materials)
	{
		o.materials = {};
		for(var i in this.materials)
			o.materials[ i ] = this.materials[i].serialize();
	}
	*/

	//serialize scene components
	//this.serializeComponents(o);

	LEvent.trigger(this,&quot;serializing&quot;,o);

	return o;
}

/**
* loads a scene from a JSON description
*
* @method load
* @param {String} url where the JSON object containing the scene is stored
* @param {Function}[on_complete=null] the callback to call when the loading is complete
* @param {Function}[on_error=null] the callback to call if there is a  loading error
*/

SceneTree.prototype.load = function(url, on_complete, on_error)
{
	if(!url) return;
	var that = this;
	var nocache = ResourcesManager.getNoCache(true);
	if(nocache)
		url += (url.indexOf(&quot;?&quot;) == -1 ? &quot;?&quot; : &quot;&amp;&quot;) + nocache;


	LS.request({
		url: url,
		dataType: &#x27;json&#x27;,
		success: inner_success,
		error: inner_error
	});

	function inner_success(response)
	{
		that.init();
		that.configure(response);
		that.loadResources(inner_all_loaded);
		LEvent.trigger(that,&quot;scene_loaded&quot;);
	}

	function inner_all_loaded()
	{
		if(on_complete)
			on_complete(that, url);
		LEvent.trigger(that,&quot;complete_scene_loaded&quot;);
	}

	function inner_error(err)
	{
		trace(&quot;Error loading scene: &quot; + url + &quot; -&gt; &quot; + err);
		if(on_error)
			on_error(url);
	}
}

SceneTree.prototype.appendScene = function(scene)
{
	//clone: because addNode removes it from scene.nodes array
	var nodes = scene.root.childNodes;

	/*
	//bring materials
	for(var i in scene.materials)
		this.materials[i] = scene.materials[i];
	*/
	
	//add every node one by one
	for(var i in nodes)
	{
		var node = nodes[i];
		var new_node = new LS.SceneNode( node.id );
		this.root.addChild( new_node );
		new_node.configure( node.constructor == LS.SceneNode ? node.serialize() : node  );
	}
}

SceneTree.prototype.getCamera = function()
{
	var camera = this._root.camera;
	if(camera) 
		return camera;

	if(this._cameras &amp;&amp; this._cameras.length)
		return this._cameras[0];

	this.collectData(); //slow
	return this._cameras[0];
}

SceneTree.prototype.getLight = function()
{
	return this._root.light;
}

/*
SceneTree.prototype.removeNode = function(node)
{
	if(!node._in_tree || node._in_tree != this)
		return;
	node.parentNode.removeChild(node);
}
*/

SceneTree.prototype.onNodeAdded = function(e,node)
{
	//remove from old scene
	if(node._in_tree &amp;&amp; node._in_tree != this)
		throw(&quot;Cannot add a node from other scene, clone it&quot;);

	//generate unique id
	if(node.id &amp;&amp; node.id != -1)
	{
		if(this._nodes_by_id[node.id] != null)
			node.id = node.id + &quot;_&quot; + (Math.random() * 1000).toFixed(0);
		this._nodes_by_id[node.id] = node;
	}

	//store
	this._nodes.push(node);

	//LEvent.trigger(node,&quot;onAddedToScene&quot;, this);
	node.processActionInComponents(&quot;onAddedToScene&quot;,this); //send to components
	LEvent.trigger(this,&quot;nodeAdded&quot;, node);
	LEvent.trigger(this,&quot;change&quot;);
}

SceneTree.prototype.onNodeRemoved = function(e,node)
{
	var pos = this._nodes.indexOf(node);
	if(pos == -1) return;

	this._nodes.splice(pos,1);
	if(node.id)
		delete this._nodes_by_id[ node.id ];

	node.processActionInComponents(&quot;onRemovedFromNode&quot;,this); //send to components
	node.processActionInComponents(&quot;onRemovedFromScene&quot;,this); //send to components

	LEvent.trigger(this,&quot;nodeRemoved&quot;, node);
	LEvent.trigger(this,&quot;change&quot;);
	return true;
}


SceneTree.prototype.getNodes = function()
{
	return this._nodes;
}

/*
SceneTree.prototype.getNodes = function()
{
	var r = [];
	getnodes(this.root, r);

	function getnodes(node, result)
	{
		for(var i in node._children)
		{
			var n = node._children[i];
			result.push(n);
			if(n._children &amp;&amp; n._children.length)
				getnodes(n,result);
		}
	}

	return r;
}
*/

/**
* retrieves a Node
*
* @method getNode
* @param {String} id node id
* @return {Object} the node or null if it didnt find it
*/

SceneTree.prototype.getNode = function(id)
{
	return this._nodes_by_id[id];
}

//for those who are more traditional
SceneTree.prototype.getElementById = SceneTree.prototype.getNode;


SceneTree.prototype.filterNodes = function( filter )
{
	var r = [];
	for(var i in this._nodes)
		if( filter(this._nodes[i]) )
			r.push(this._nodes[i]);
	return r;
}



/**
* retrieves a Node
*
* @method getNodeByUid
* @param {number} uid number
* @return {Object} the node or null if it didnt find it
*/

/*
SceneTree.prototype.getNodeByUid = function(uid)
{
	for(var i in this.nodes)
		if(this.nodes[i]._uid == uid)
			return this.nodes[i];
	return null;
}
*/

/**
* retrieves a Node by its index
*
* @method getNodeByIndex
* @param {Number} node index
* @return {Object} returns the node at the &#x27;index&#x27; position in the nodes array
*/
/*
SceneTree.prototype.getNodeByIndex = function(index)
{
	return this.nodes[index];
}
*/

/**
* retrieves a Node index
*
* @method getNodeIndex
* @param {Node} node
* @return {Number} returns the node index in the nodes array
*/
/*
SceneTree.prototype.getNodeIndex = function(node)
{
	return this.nodes.indexOf(node);
}
*/

/**
* retrieves a Node
*
* @method getNodesByClass
* @param {String} className class name
* @return {Object} returns all the nodes that match this class name
*/

/*
SceneTree.prototype.getNodesByClass = function(classname)
{
	var r = [];
	for (var i in this.nodes)
		if(this.nodes[i].className &amp;&amp; this.nodes[i].className.split(&quot; &quot;).indexOf(classname) != -1)
			r.push(this.nodes[i]);
	return r;
}
*/


/**
* loads all the resources of all the nodes in this scene
* it sends a signal to every node to get all the resources info
* and load them in bulk using the ResourceManager
*
* @method loadResources
*/

SceneTree.prototype.loadResources = function(on_complete)
{
	var res = {};

	//scene resources
	for(var i in this.textures)
		if(this.textures[i])
			res[ this.textures[i] ] = Texture;

	if(this.light) this.light.getResources(res);

	//resources from nodes
	for(var i in this._nodes)
		this._nodes[i].getResources(res);

	//used for scenes with special repository folders
	var options = {};
	if(this.local_repository)
		options.local_repository = this.local_repository;

	//count resources
	var num_resources = 0;
	for(var i in res)
		++num_resources;

	//load them
	if(num_resources == 0)
	{
		if(on_complete)
			on_complete();
		return;
	}

	LEvent.bind( LS.ResourcesManager, &quot;end_loading_resources&quot;, on_loaded );
	LS.ResourcesManager.loadResources(res);

	function on_loaded()
	{
		LEvent.unbind( LS.ResourcesManager, &quot;end_loading_resources&quot;, on_loaded );
		if(on_complete)
			on_complete();
	}
}

/**
* start the scene (triggers and start event)
*
* @method start
* @param {Number} dt delta time
*/
SceneTree.prototype.start = function()
{
	if(this._state == &quot;running&quot;) return;

	this._state = &quot;running&quot;;
	this._start_time = getTime() * 0.001;
	LEvent.trigger(this,&quot;start&quot;,this);
	this.triggerInNodes(&quot;start&quot;);
}

/**
* stop the scene (triggers and start event)
*
* @method stop
* @param {Number} dt delta time
*/
SceneTree.prototype.stop = function()
{
	if(this._state == &quot;stopped&quot;) return;

	this._state = &quot;stopped&quot;;
	LEvent.trigger(this,&quot;stop&quot;,this);
	this.triggerInNodes(&quot;stop&quot;);
}


/**
* renders the scene using the assigned renderer
*
* @method render
*/
SceneTree.prototype.render = function(camera, options)
{
	this._renderer.render(this, camera, options);
}

SceneTree.prototype.collectData = function()
{
	//var nodes = scene.nodes;
	var nodes = this.getNodes();
	var instances = [];
	var lights = [];
	var cameras = [];
	var colliders = [];

	//collect render instances, lights and cameras
	for(var i in nodes)
	{
		var node = nodes[i];

		if(node.flags.visible == false) //skip invisibles
			continue;

		//trigger event
		LEvent.trigger(node, &quot;computeVisibility&quot;); //, {camera: camera} options: options }

		//compute global matrix
		if(node.transform)
			node.transform.updateGlobalMatrix();

		//special node deformers (done here because they are shared for every node)
			//this should be moved to Renderer but not a clean way to do it
			var node_macros = {};
			LEvent.trigger(node, &quot;computingShaderMacros&quot;, node_macros );

			var node_uniforms = {};
			LEvent.trigger(node, &quot;computingShaderUniforms&quot;, node_uniforms );

		//store info
		node._macros = node_macros;
		node._uniforms = node_uniforms;
		node._instances = [];

		//get render instances: remember, triggers only support one parameter
		LEvent.trigger(node,&quot;collectRenderInstances&quot;, node._instances );
		LEvent.trigger(node,&quot;collectPhysicInstances&quot;, colliders );
		LEvent.trigger(node,&quot;collectLights&quot;, lights );
		LEvent.trigger(node,&quot;collectCameras&quot;, cameras );

		instances = instances.concat( node._instances );
	}

	//for each render instance collected
	for(var j in instances)
	{
		var instance = instances[j];
		instance.computeNormalMatrix();
		//compute the axis aligned bounding box
		if(!(instance.flags &amp; RI_IGNORE_FRUSTUM))
			instance.updateAABB();
	}

	//for each physics instance collected
	for(var j in colliders)
	{
		var collider = colliders[j];
		collider.updateAABB();
	}

	this._instances = instances;
	this._lights = lights;
	this._cameras = cameras;
	this._colliders = colliders;

	//remember when was last time I collected to avoid repeating it
	this._last_collect_frame = this._frame;
}


SceneTree.prototype.update = function(dt)
{
	LEvent.trigger(this,&quot;beforeUpdate&quot;, this);

	this._global_time = getTime() * 0.001;
	this._time = this._global_time - this._start_time;
	this._last_dt = dt;

	LEvent.trigger(this,&quot;update&quot;, dt);
	this.triggerInNodes(&quot;update&quot;,dt, true);

	LEvent.trigger(this,&quot;afterUpdate&quot;, this);
}

/**
* triggers an event to all nodes in the scene
*
* @method triggerInNodes
* @param {String} event_type event type name
* @param {Object} data data to send associated to the event
*/

SceneTree.prototype.triggerInNodes = function(event_type, data)
{
	LEvent.triggerArray( this._nodes, event_type, data);
}


SceneTree.prototype.generateUniqueNodeName = function(prefix)
{
	prefix = prefix || &quot;node&quot;;
	var i = 1;

	var pos = prefix.lastIndexOf(&quot;_&quot;);
	if(pos)
	{
		var n = prefix.substr(pos+1);
		if( parseInt(n) )
		{
			i = parseInt(n);
			prefix = prefix.substr(0,pos);
		}
	}

	var node_name = prefix + &quot;_&quot; + i;
	while( this.getNode(node_name) != null )
		node_name = prefix + &quot;_&quot; + (i++);
	return node_name;
}


SceneTree.prototype.refresh = function()
{
	this._must_redraw = true;
}

SceneTree.prototype.getTime = function()
{
	return this._time;
}

//****************************************************************************

/**
* The SceneNode class represents and object in the scene
* Is the base class for all objects in the scene as meshes, lights, cameras, and so
*
* @class SceneNode
* @param{String} id the id (otherwise a random one is computed)
* @constructor
*/

function SceneNode(id)
{
	//Generic
	this.id = id || (&quot;node_&quot; + (Math.random() * 10000).toFixed(0)); //generate random number
	this._uid = LS.generateUId();

	//this.className = &quot;&quot;;
	//this.mesh = &quot;&quot;;

	//flags
	this.flags = {
		visible: true,
		selectable: true,
		two_sided: false,
		flip_normals: false,
		//seen_by_camera: true,
		//seen_by_reflections: true,
		cast_shadows: true,
		receive_shadows: true,
		ignore_lights: false, //not_affected_by_lights
		alpha_test: false,
		alpha_shadows: false,
		depth_test: true,
		depth_write: true
	};

	//Basic components
	this._components = []; //used for logic actions
	this.addComponent( new Transform() );

	//material
	//this.material = new Material();
	this.extra = {}; //for extra info
}

//get methods from other classes
LS.extendClass(SceneNode, ComponentContainer); //container methods
LS.extendClass(SceneNode, CompositePattern); //container methods

/**
* changes the node id (its better to do not change the id, it can lead to unexpected results)
* remember that two nodes can&#x27;t have the same id
* @method setId
* @param {String} new_id the new id
* @return {Object} returns true if the name changed
*/

SceneNode.prototype.setId = function(new_id)
{
	if(this.id == new_id) return true; //no changes

	var scene = this._in_tree;
	if(!scene)
	{
		this.id = new_id;
		return;
	}

	if( scene.getNode(new_id) != null)
	{
		console.error(&quot;ID already in use&quot;);
		return false;
	}

	if(this.id)
		delete scene._nodes_by_id[this.id];

	this.id = new_id;
	if(this.id)
		scene._nodes_by_id[ this.id ] = this;

	LEvent.trigger(this,&quot;idChanged&quot;, new_id);
	LEvent.trigger(Scene,&quot;nodeIdChanged&quot;, this);
	return true;
}

SceneNode.prototype.getResources = function(res, include_children)
{
	//resources in components
	for(var i in this._components)
		if( this._components[i].getResources )
			this._components[i].getResources( res );

	//res in material
	if(this.material)
	{
		if(typeof(this.material) == &quot;string&quot;)
		{
			if(this.material[0] != &quot;:&quot;) //not a local material, then its a reference
			{
				res[this.material] = LS.Material;
			}
		}
		else //get the material to get the resources
		{
			var mat = this.getMaterial();
			if(mat)
				mat.getResources( res );
		}
	}

	//prefab
	if(this.prefab)
		res[this.prefab] = LS.Prefab;

	//propagate
	if(include_children)
		for(var i in this._children)
			this._children[i].getResources(res, true);

	return res;
}

SceneNode.prototype.getTransform = function() {
	return this.transform;
}

//Mesh component
SceneNode.prototype.getMesh = function() {
	var mesh = this.mesh;
	if(!mesh &amp;&amp; this.meshrenderer)
		mesh = this.meshrenderer.mesh;
	if(!mesh) return null;
	if(mesh.constructor === String)
		return ResourcesManager.meshes[mesh];
	return mesh;
}

//Light component
SceneNode.prototype.getLight = function() {
	return this.light;
}

//Camera component
SceneNode.prototype.getCamera = function() {
	return this.camera;
}

SceneNode.prototype.getLODMesh = function() {
	var mesh = this.lod_mesh;
	if(!mesh &amp;&amp; this.meshrenderer)
		mesh = this.meshrenderer.lod_mesh;
	if(!mesh) return null;
	if(mesh.constructor === String)
		return ResourcesManager.meshes[mesh];
	return mesh;
}

SceneNode.prototype.setMesh = function(mesh_name, submesh_id)
{
	if(this.meshrenderer)
	{
		if(typeof(mesh_name) == &quot;string&quot;)
			this.meshrenderer.configure({ mesh: mesh_name, submesh_id: submesh_id });
		else
			this.meshrenderer.mesh = mesh_name;
	}
	else
		this.addComponent(new MeshRenderer({ mesh: mesh_name, submesh_id: submesh_id }));
}

SceneNode.prototype.loadAndSetMesh = function(mesh_filename, options)
{
	options = options || {};

	if(ResourcesManager.meshes[mesh_filename] || !mesh_filename )
	{
		this.setMesh( mesh_filename );
		if(options.on_complete) options.on_complete( ResourcesManager.meshes[mesh_filename] ,this);
		return;
	}

	var that = this;
	var loaded = ResourcesManager.load(mesh_filename, options, function(mesh){
		that.setMesh(mesh.filename);
		that.loading -= 1;
		if(that.loading == 0)
		{
			LEvent.trigger(that,&quot;resource_loaded&quot;,that);
			delete that.loading;
		}
		if(options.on_complete) options.on_complete(mesh,that);
	});

	if(!loaded)
	{
		if(!this.loading)
		{
			this.loading = 1;

			LEvent.trigger(this,&quot;resource_loading&quot;);
		}
		else
			this.loading += 1;
	}
}

SceneNode.prototype.getMaterial = function()
{
	if (!this.material) return null;
	if(this.material.constructor === String)
		return this._in_tree ? LS.ResourcesManager.materials[ this.material ] : null;
	return this.material;
}


SceneNode.prototype.setPrefab = function(prefab_name)
{
	this._prefab_name = prefab_name;
	var prefab = LS.ResourcesManager.resources[prefab_name];
	if(!prefab)
		return;


}


/**
* remember clones this node and returns the new copy (you need to add it to the scene to see it)
* @method clone
* @return {Object} returns a cloned version of this node
*/

SceneNode.prototype.clone = function()
{
	var scene = this._in_tree;

	var new_name = scene ? scene.generateUniqueNodeName( this.id ) : this.id ;
	var newnode = new SceneNode( new_name );
	var info = this.serialize();
	info.id = null;
	newnode.configure( info );

	/*
	//clone children (none of them is added to the SceneTree)
	for(var i in this._children)
	{
		var new_child_name = scene ? scene.generateUniqueNodeName( this._children[i].id ) : this._children[i].id;
		var childnode = new SceneNode( new_child_name );
		var info = this._children[i].serialize();
		info.id = null;
		childnode.configure( info );
		newnode.addChild(childnode);
	}
	*/

	return newnode;
}

/**
* Configure this node from an object containing the info
* @method configure
* @param {Object} info the object with all the info (comes from the serialize method)
*/
SceneNode.prototype.configure = function(info)
{
	if (info.id) this.setId(info.id);
	if (info.className)	this.className = info.className;

	//useful parsing
	if(info.mesh)
	{
		var mesh = info.mesh;
		if(typeof(mesh) == &quot;string&quot;)
			mesh = ResourcesManager.meshes[mesh];

		if(mesh)
		{
			if(mesh.bones)
				this.addComponent( new SkinnedMeshRenderer({ mesh: info.mesh, submesh_id: info.submesh_id }) );
			else
				this.addComponent( new MeshRenderer({ mesh: info.mesh, submesh_id: info.submesh_id, morph_targets: info.morph_targets }) );
		}
	}

	//first the no components
	if(info.material)
	{
		var mat_class = info.material.material_class;
		if(!mat_class) 
			mat_class = &quot;Material&quot;;
		this.material = typeof(info.material) == &quot;string&quot; ? info.material : new LS.MaterialClasses[mat_class](info.material);
	}

	if(info.flags) //merge
		for(var i in info.flags)
			this.flags[i] = info.flags[i];
	
	//DEPRECATED: hardcoded components
	if(info.transform) this.transform.configure( info.transform ); //all nodes have a transform
	if(info.light) this.addComponent( new Light(info.light) );
	if(info.camera)	this.addComponent( new Camera(info.camera) );

	//DEPRECATED: model in matrix format
	if(info.model) this.transform.fromMatrix( info.model ); 

	if(info.prefab) this.prefab = info.prefab;

	//add animation
	if(info.animations)
	{
		this.animations = info.animations;
		this.addComponent( new PlayAnimation({animation:this.animations}) );
	}

	//extra user info
	if(info.extra)
		this.extra = info.extra;

	if(info.comments)
		this.comments = info.comments;

	//restore components
	if(info.components)
		this.configureComponents(info);

	this.configureChildren(info);

	//ierarchy: this goes last because it needs to read transform
	/*
	if(info.parent_id) //name of the parent
	{
		if(this._in_tree)
		{
			var parent = this._in_tree.getNode( info.parent_id );
			if(parent) 
				parent.addChild( this );
		}
		else
			this.parent = info.parent_id;
	}
	*/

	LEvent.trigger(this,&quot;configure&quot;,info);
}

/**
* Serializes this node by creating an object with all the info
* it contains info about the components too
* @method serialize
* @return {Object} returns the object with the info
*/
SceneNode.prototype.serialize = function()
{
	var o = {};

	if(this.id) o.id = this.id;
	if(this.className) o.className = this.className;

	//modules
	if(this.mesh &amp;&amp; typeof(this.mesh) == &quot;string&quot;) o.mesh = this.mesh; //do not save procedural meshes
	if(this.submesh_id != null) o.submesh_id = this.submesh_id;
	if(this.material) o.material = typeof(this.material) == &quot;string&quot; ? this.material : this.material.serialize();
	if(this.prefab) o.prefab = this.prefab;

	if(this.flags) o.flags = cloneObject(this.flags);

	//extra user info
	if(this.extra) o.extra = this.extra;
	if(this.comments) o.comments = this.comments;

	if(this._children)
		o.children = this.serializeChildren();

	//save children ierarchy
	//if(this.parentNode)
	//	o.parent_id = this.parentNode.id;
	/*
	if(this._children &amp;&amp; this._children.length)
	{
		o.children = [];
		for(var i in this._children)
			o.children.push( this._children[i].id );
	}
	*/

	//save components
	this.serializeComponents(o);

	//extra serializing info
	LEvent.trigger(this,&quot;serialize&quot;,o);

	return o;
}

SceneNode.prototype._onChildAdded = function(child_node, recompute_transform)
{
	if(recompute_transform &amp;&amp; this.transform)
	{
		var M = child_node.transform.getGlobalMatrix(); //get son transform
		var M_parent = this.transform.getGlobalMatrix(); //parent transform
		mat4.invert(M_parent,M_parent);
		child_node.transform.fromMatrix( mat4.multiply(M_parent,M_parent,M) );
		child_node.transform.getGlobalMatrix(); //refresh
	}
	//link transform
	if(this.transform)
		child_node.transform._parent = this.transform;
}

SceneNode.prototype._onChangeParent = function(future_parent, recompute_transform)
{
	if(recompute_transform &amp;&amp; future_parent.transform)
	{
		var M = this.transform.getGlobalMatrix(); //get son transform
		var M_parent = future_parent.transform.getGlobalMatrix(); //parent transform
		mat4.invert(M_parent,M_parent);
		this.transform.fromMatrix( mat4.multiply(M_parent,M_parent,M) );
	}
	//link transform
	if(future_parent.transform)
		this.transform._parent = future_parent.transform;
}

SceneNode.prototype._onChildRemoved = function(node, recompute_transform)
{
	if(this.transform)
	{
		//unlink transform
		if(recompute_transform)
		{
			var m = node.transform.getGlobalMatrix();
			node.transform._parent = null;
			node.transform.fromMatrix(m);
		}
		else
			node.transform._parent = null;
	}
}

//***************************************************************************

//create one default scene

LS.SceneTree = SceneTree;
LS.SceneNode = SceneNode;
var Scene = new SceneTree();

LS.newMeshNode = function(id,mesh_name)
{
	var node = new SceneNode(id);
	node.addComponent( new MeshRenderer() );
	node.setMesh(mesh_name);
	return node;
}

LS.newLightNode = function(id)
{
	var node = new SceneNode(id);
	node.addComponent( new Light() );
	return node;
}

LS.newCameraNode = function(id)
{
	var node = new SceneNode(id);
	node.addComponent( new Camera() );
	return node;
}

//*******************************/


    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
