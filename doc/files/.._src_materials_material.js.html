<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>../src/materials/material.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="../assets/css/logo.png" title=""></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="../classes/LS.Animation.html">LS.Animation</a></li>
            
                <li><a href="../classes/LS.Animation.Track.html">LS.Animation.Track</a></li>
            
                <li><a href="../classes/LS.Collision.html">LS.Collision</a></li>
            
                <li><a href="../classes/LS.Component.html">LS.Component</a></li>
            
                <li><a href="../classes/LS.ComponentContainer.html">LS.ComponentContainer</a></li>
            
                <li><a href="../classes/LS.Components.Camera.html">LS.Components.Camera</a></li>
            
                <li><a href="../classes/LS.Components.CameraController.html">LS.Components.CameraController</a></li>
            
                <li><a href="../classes/LS.Components.CameraFX.html">LS.Components.CameraFX</a></li>
            
                <li><a href="../classes/LS.Components.CustomData.html">LS.Components.CustomData</a></li>
            
                <li><a href="../classes/LS.Components.FollowNode.html">LS.Components.FollowNode</a></li>
            
                <li><a href="../classes/LS.Components.FXGraphComponent.html">LS.Components.FXGraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.GeometricPrimitive.html">LS.Components.GeometricPrimitive</a></li>
            
                <li><a href="../classes/LS.Components.GraphComponent.html">LS.Components.GraphComponent</a></li>
            
                <li><a href="../classes/LS.Components.Knob.html">LS.Components.Knob</a></li>
            
                <li><a href="../classes/LS.Components.Light.html">LS.Components.Light</a></li>
            
                <li><a href="../classes/LS.Components.LightFX.html">LS.Components.LightFX</a></li>
            
                <li><a href="../classes/LS.Components.NodeManipulator.html">LS.Components.NodeManipulator</a></li>
            
                <li><a href="../classes/LS.Components.PlayAnimation.html">LS.Components.PlayAnimation</a></li>
            
                <li><a href="../classes/LS.Components.Poser.html">LS.Components.Poser</a></li>
            
                <li><a href="../classes/LS.Components.RealtimeReflector.html">LS.Components.RealtimeReflector</a></li>
            
                <li><a href="../classes/LS.Components.Script.html">LS.Components.Script</a></li>
            
                <li><a href="../classes/LS.Components.Spherize.html">LS.Components.Spherize</a></li>
            
                <li><a href="../classes/LS.Components.Target.html">LS.Components.Target</a></li>
            
                <li><a href="../classes/LS.Components.Transform.html">LS.Components.Transform</a></li>
            
                <li><a href="../classes/LS.CompositePattern.html">LS.CompositePattern</a></li>
            
                <li><a href="../classes/LS.Draw.html">LS.Draw</a></li>
            
                <li><a href="../classes/LS.Formats.html">LS.Formats</a></li>
            
                <li><a href="../classes/LS.LS.html">LS.LS</a></li>
            
                <li><a href="../classes/LS.LScript.html">LS.LScript</a></li>
            
                <li><a href="../classes/LS.LSQ.html">LS.LSQ</a></li>
            
                <li><a href="../classes/LS.Material.html">LS.Material</a></li>
            
                <li><a href="../classes/LS.Physics.html">LS.Physics</a></li>
            
                <li><a href="../classes/LS.PhysicsInstance.html">LS.PhysicsInstance</a></li>
            
                <li><a href="../classes/LS.Picking.html">LS.Picking</a></li>
            
                <li><a href="../classes/LS.Player.html">LS.Player</a></li>
            
                <li><a href="../classes/LS.Prefab.html">LS.Prefab</a></li>
            
                <li><a href="../classes/LS.Project.html">LS.Project</a></li>
            
                <li><a href="../classes/LS.Renderer.html">LS.Renderer</a></li>
            
                <li><a href="../classes/LS.RenderInstance.html">LS.RenderInstance</a></li>
            
                <li><a href="../classes/LS.RenderSettings.html">LS.RenderSettings</a></li>
            
                <li><a href="../classes/LS.ResourcesManager.html">LS.ResourcesManager</a></li>
            
                <li><a href="../classes/LS.SceneNode.html">LS.SceneNode</a></li>
            
                <li><a href="../classes/LS.SceneTree.html">LS.SceneTree</a></li>
            
                <li><a href="../classes/LS.ShaderQuery.html">LS.ShaderQuery</a></li>
            
                <li><a href="../classes/LS.ShadersManager.html">LS.ShadersManager</a></li>
            
                <li><a href="../classes/LS.StandardMaterial.html">LS.StandardMaterial</a></li>
            
                <li><a href="../classes/LS.TextureFX.html">LS.TextureFX</a></li>
            
                <li><a href="../classes/LS.WBin.html">LS.WBin</a></li>
            
                <li><a href="../classes/Rotator.html">Rotator</a></li>
            
                <li><a href="../classes/VRCameraController.html">VRCameraController</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: ../src/materials/material.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">



//Material class **************************
/* Warning: a material is not a component, because it can be shared by multiple nodes */

/**
* Material class contains all the info about how a mesh should be rendered, more in a highlevel format.
* Most of the info is Colors, factors and Textures but it can also specify a shader or some flags.
* Materials could be shared among different objects.
* @namespace LS
* @class Material
* @constructor
* @param {String} object to configure from
*/

function Material(o)
{
	this.name = &quot;&quot;;
	this.uid = LS.generateUId(&quot;MAT-&quot;);
	this._dirty = true;

	//this.shader_name = null; //default shader
	this._color = new Float32Array([1.0,1.0,1.0,1.0]);
	this.createProperty(&quot;diffuse&quot;, new Float32Array([1.0,1.0,1.0]), &quot;color&quot; );
	this.shader_name = &quot;global&quot;;
	this.blend_mode = LS.Blend.NORMAL;

	this._specular_data = vec2.fromValues( 0.1, 10.0 );

	//this.reflection_factor = 0.0;	

	//textures
	this.uvs_matrix = new Float32Array([1,0,0, 0,1,0, 0,0,1]);
	this.textures = {};

	this._query = new ShaderQuery();

	//properties with special storage (multiple vars shared among single properties)

	Object.defineProperty( this, &#x27;color&#x27;, {
		get: function() { return this._color.subarray(0,3); },
		set: function(v) { vec3.copy( this._color, v ); },
		enumerable: true
	});

	Object.defineProperty( this, &#x27;opacity&#x27;, {
		get: function() { return this._color[3]; },
		set: function(v) { this._color[3] = v; },
		enumerable: true
	});

	Object.defineProperty( this, &#x27;specular_factor&#x27;, {
		get: function() { return this._specular_data[0]; },
		set: function(v) { this._specular_data[0] = v; },
		enumerable: true
	});

	Object.defineProperty( this, &#x27;specular_gloss&#x27;, {
		get: function() { return this._specular_data[1]; },
		set: function(v) { this._specular_data[1] = v; },
		enumerable: true
	});

	if(o) 
		this.configure(o);
}

Material[&quot;@color&quot;] = { type:&quot;color&quot; };
Material[&quot;@blend_mode&quot;] = { type: &quot;enum&quot;, values: LS.Blend };

Material.icon = &quot;mini-icon-material.png&quot;;


//material info attributes, use this to avoid errors when settings the attributes of a material

/**
* Surface color
* @property color
* @type {vec3}
* @default [1,1,1]
*/
Material.COLOR = &quot;color&quot;;
/**
* Opacity. It must be &lt; 1 to enable alpha sorting. If it is &lt;= 0 wont be visible.
* @property opacity
* @type {number}
* @default 1
*/
Material.OPACITY = &quot;opacity&quot;;

/**
* Blend mode, it could be any of Blend options (NORMAL,ALPHA, ADD, SCREEN)
* @property blend_mode
* @type {String}
* @default Blend.NORMAL
*/
Material.BLEND_MODE = &quot;blend_mode&quot;;

Material.SPECULAR_FACTOR = &quot;specular_factor&quot;;
/**
* Specular glossiness: the glossines (exponent) of specular light
* @property specular_gloss
* @type {number}
* @default 10
*/
Material.SPECULAR_GLOSS = &quot;specular_gloss&quot;;


Material.OPACITY_TEXTURE = &quot;opacity&quot;;	//used for baked GI
Material.COLOR_TEXTURE = &quot;color&quot;;	//material color
Material.AMBIENT_TEXTURE = &quot;ambient&quot;;
Material.SPECULAR_TEXTURE = &quot;specular&quot;; //defines specular factor and glossiness per pixel
Material.EMISSIVE_TEXTURE = &quot;emissive&quot;;
Material.ENVIRONMENT_TEXTURE = &quot;environment&quot;;

Material.COORDS_UV0 = &quot;0&quot;;
Material.COORDS_UV1 = &quot;1&quot;;
Material.COORDS_UV_TRANSFORMED = &quot;transformed&quot;;
Material.COORDS_SCREEN = &quot;screen&quot;;					//project to screen space
Material.COORDS_SCREENCENTERED = &quot;screen_centered&quot;;	//project to screen space and centers and corrects aspect
Material.COORDS_FLIPPED_SCREEN = &quot;flipped_screen&quot;;	//used for realtime reflections
Material.COORDS_POLAR = &quot;polar&quot;;					//use view vector as polar coordinates
Material.COORDS_POLAR_REFLECTED = &quot;polar_reflected&quot;;//use reflected view vector as polar coordinates
Material.COORDS_POLAR_VERTEX = &quot;polar_vertex&quot;;		//use normalized vertex as polar coordinates
Material.COORDS_WORLDXZ = &quot;worldxz&quot;;
Material.COORDS_WORLDXY = &quot;worldxy&quot;;
Material.COORDS_WORLDYZ = &quot;worldyz&quot;;

Material.TEXTURE_COORDINATES = [ Material.COORDS_UV0, Material.COORDS_UV1, Material.COORDS_UV_TRANSFORMED, Material.COORDS_SCREEN, Material.COORDS_SCREENCENTERED, Material.COORDS_FLIPPED_SCREEN, Material.COORDS_POLAR, Material.COORDS_POLAR_REFLECTED, Material.COORDS_POLAR_VERTEX, Material.COORDS_WORLDXY, Material.COORDS_WORLDXZ, Material.COORDS_WORLDYZ ];
Material.DEFAULT_UVS = { &quot;normal&quot;:Material.COORDS_UV0, &quot;displacement&quot;:Material.COORDS_UV0, &quot;environment&quot;: Material.COORDS_POLAR_REFLECTED, &quot;irradiance&quot; : Material.COORDS_POLAR };

Material.available_shaders = [&quot;default&quot;,&quot;global&quot;,&quot;lowglobal&quot;,&quot;phong_texture&quot;,&quot;flat&quot;,&quot;normal&quot;,&quot;phong&quot;,&quot;flat_texture&quot;,&quot;cell_outline&quot;];
Material.texture_channels = [ Material.COLOR_TEXTURE, Material.OPACITY_TEXTURE, Material.AMBIENT_TEXTURE, Material.SPECULAR_TEXTURE, Material.EMISSIVE_TEXTURE, Material.ENVIRONMENT_TEXTURE ];

Material.prototype.applyToRenderInstance = function(ri)
{
	if(this.blend_mode != LS.Blend.NORMAL)
		ri.flags |= RI_BLEND;

	if(this.blend_mode == LS.Blend.CUSTOM &amp;&amp; this.blend_func)
		ri.blend_func = this.blend_func;
	else
		ri.blend_func = LS.BlendFunctions[ this.blend_mode ];
}

// RENDERING METHODS
Material.prototype.fillShaderQuery = function(scene)
{
	var query = this._query;
	query.clear();

	//iterate through textures in the material
	for(var i in this.textures) 
	{
		var sampler = this.getTextureSampler(i);
		if(!sampler)
			continue;
		var uvs = sampler.uvs || Material.DEFAULT_UVS[i] || &quot;0&quot;;

		var texture = Material.getTextureFromSampler( sampler );
		if(!texture) //loading or non-existant
			continue;

		query.macros[ &quot;USE_&quot; + i.toUpperCase() + (texture.texture_type == gl.TEXTURE_2D ? &quot;_TEXTURE&quot; : &quot;_CUBEMAP&quot;) ] = &quot;uvs_&quot; + uvs;
	}

	//if(this.reflection_factor &gt; 0.0) 
	//	macros.USE_REFLECTION = &quot;&quot;;	

	//extra macros
	if(this.extra_macros)
		for(var im in this.extra_macros)
			query.macros[im] = this.extra_macros[im];
}

//Fill with info about the light
// This is hard to precompute and reuse because here macros depend on the node (receive_shadows?), on the scene (shadows enabled?), on the material (contant diffuse?) 
// and on the light itself
/*
Material.prototype.getLightShaderMacros = function(light, node, scene, render_settings)
{
	var macros = {};

	var use_shadows = light.cast_shadows &amp;&amp; light._shadowmap &amp;&amp; light._light_matrix != null &amp;&amp; !render_settings.shadows_disabled;

	//light macros
	if(light.use_diffuse &amp;&amp; !this.constant_diffuse)
		macros.USE_DIFFUSE_LIGHT = &quot;&quot;;
	if(light.use_specular &amp;&amp; this.specular_factor &gt; 0)
		macros.USE_SPECULAR_LIGHT = &quot;&quot;;
	if(light.type == Light.DIRECTIONAL)
		macros.USE_DIRECTIONAL_LIGHT = &quot;&quot;;
	else if(light.type == Light.SPOT)
		macros.USE_SPOT_LIGHT = &quot;&quot;;
	if(light.spot_cone)
		macros.USE_SPOT_CONE = &quot;&quot;;
	if(light.linear_attenuation)
		macros.USE_LINEAR_ATTENUATION = &quot;&quot;;
	if(light.range_attenuation)
		macros.USE_RANGE_ATTENUATION = &quot;&quot;;

	var light_projective_texture = light.projective_texture;
	if(light_projective_texture &amp;&amp; light_projective_texture.constructor == String)
		light_projective_texture = ResourcesManager.textures[light_projective_texture];

	if(light_projective_texture)
	{
		macros.USE_PROJECTIVE_LIGHT = &quot;&quot;;
		if(light_projective_texture.texture_type == gl.TEXTURE_CUBE_MAP)
			macros.USE_PROJECTIVE_LIGHT_CUBEMAP = &quot;&quot;;
	}

	var light_average_texture = light.average_texture;
	if(light_average_texture &amp;&amp; light_average_texture.constructor == String)
		light_average_texture = ResourcesManager.textures[light_average_texture];
	if(light_average_texture)
		macros.USE_TEXTURE_AVERAGE_LIGHT = &quot;&quot;;

	//if(vec3.squaredLength( light.color ) &lt; 0.001 || node.flags.ignore_lights)
	//	macros.USE_IGNORE_LIGHT = &quot;&quot;;

	if(light.offset &gt; 0.001)
		macros.USE_LIGHT_OFFSET = &quot;&quot;;

	if(use_shadows &amp;&amp; node.flags.receive_shadows != false)
	{
		macros.USE_SHADOW_MAP = &quot;&quot;;
		if(light._shadowmap &amp;&amp; light._shadowmap.texture_type == gl.TEXTURE_CUBE_MAP)
			macros.USE_SHADOW_CUBEMAP = &quot;&quot;;
		if(light.hard_shadows || macros.USE_SHADOW_CUBEMAP != null)
			macros.USE_HARD_SHADOWS = &quot;&quot;;

		macros.SHADOWMAP_OFFSET = &quot;&quot;;
	}

	return macros;
}
*/

Material.prototype.fillUniforms = function( scene, options )
{
	var uniforms = {};
	var samplers = {};

	uniforms.u_material_color = this._color;
	uniforms.u_ambient_color = scene.info ? scene.info.ambient_color : this._diffuse;
	uniforms.u_diffuse_color = this._diffuse;

	uniforms.u_specular = this._specular_data;
	uniforms.u_texture_matrix = this.uvs_matrix;

	uniforms.u_reflection = this.reflection_factor;

	//iterate through textures in the material
	for(var i in this.textures) 
	{
		var texture_info = this.getTextureSampler(i);
		if(!texture_info) continue;

		var texture = Material.getTextureFromSampler( texture_info );
		if(!texture) //loading or non-existant
			continue;

		samplers[ i + (texture.texture_type == gl.TEXTURE_2D ? &quot;_texture&quot; : &quot;_cubemap&quot;) ] = texture_info;
	}

	//add extra uniforms
	for(var i in this.extra_uniforms)
		uniforms[i] = this.extra_uniforms[i];

	this._uniforms = uniforms;
	this._samplers = samplers; //samplers without fixed slot
}

/**
* Configure the material getting the info from the object
* @method configure
* @param {Object} object to configure from
*/
Material.prototype.configure = function(o)
{
	for(var i in o)
		this.setProperty( i, o[i] );
}

/**
* Serialize this material 
* @method serialize
* @return {Object} object with the serialization info
*/
Material.prototype.serialize = function()
{
	 var o = LS.cloneObject(this);
	 o.material_class = LS.getObjectClassName(this);
	 return o;
}


/**
* Clone this material (keeping the class)
* @method clone
* @return {Material} Material instance
*/
Material.prototype.clone = function()
{
	var data = this.serialize();
	if(data.uid)
		delete data.uid;
	return new this.constructor( JSON.parse( JSON.stringify( data )) );
}

/**
* Loads and assigns a texture to a channel
* @method loadAndSetTexture
* @param {Texture || url} texture_or_filename
* @param {String} channel
*/
Material.prototype.loadAndSetTexture = function(channel, texture_or_filename, options)
{
	options = options || {};
	var that = this;
	//if(!this.material) this.material = new Material();

	if( typeof(texture_or_filename) === &quot;string&quot; ) //it could be the url or the internal texture name 
	{
		if(texture_or_filename[0] != &quot;:&quot;)//load if it is not an internal texture
			LS.ResourcesManager.load(texture_or_filename,options, function(texture) {
				that.setTexture(channel, texture);
				if(options.on_complete)
					options.on_complete();
			});
		else
			this.setTexture(channel, texture_or_filename);
	}
	else //otherwise just assign whatever
	{
		this.setTexture(channel, texture_or_filename);
		if(options.on_complete)
			options.on_complete();
	}
}

/**
* gets all the properties and its types
* @method getProperties
* @return {Object} object with name:type
*/
Material.prototype.getProperties = function()
{
	var o = {
		color:&quot;vec3&quot;,
		opacity:&quot;number&quot;,
		shader_name: &quot;string&quot;,
		blend_mode: &quot;number&quot;,
		specular_factor:&quot;number&quot;,
		specular_gloss:&quot;number&quot;,
		uvs_matrix:&quot;mat3&quot;
	};

	var textures = this.getTextureChannels();
	for(var i in textures)
		o[&quot;tex_&quot; + textures[i]] = &quot;Texture&quot;; //changed from Sampler
	return o;
}

/**
* gets all the properties and its types
* @method getProperty
* @return {Object} object with name:type
*/
Material.prototype.getProperty = function(name)
{
	if(name.substr(0,4) == &quot;tex_&quot;)
		return this.textures[ name.substr(4) ];
	return this[name];
}


/**
* gets all the properties and its types
* @method getProperty
* @return {Object} object with name:type
*/
Material.prototype.setProperty = function(name, value)
{
	if(name.substr(0,4) == &quot;tex_&quot;)
	{
		if( (value &amp;&amp; (value.constructor === String || value.constructor === GL.Texture)) || !value)
			this.setTexture( name.substr(4), value );
		return true;
	}

	switch(name)
	{
		//numbers
		case &quot;opacity&quot;: 
		case &quot;specular_factor&quot;:
		case &quot;specular_gloss&quot;:
		case &quot;reflection&quot;: 
		case &quot;blend_mode&quot;:
		//strings
		case &quot;shader_name&quot;:
		//bools
			this[name] = value; 
			break;
		//vectors
		case &quot;uvs_matrix&quot;:
		case &quot;color&quot;: 
			if(this[name].length == value.length)
				this[name].set( value );
			break;
		case &quot;textures&quot;:
			//legacy
			for(var i in value)
			{
				var tex = value[i];
				if(typeof(tex) == &quot;string&quot;)
					tex = { texture: tex, uvs: &quot;0&quot;, wrap: 0, minFilter: 0, magFilter: 0 };
				this.textures[i] = tex;
			}
			//this.textures = cloneObject(value);
			break;
		case &quot;transparency&quot;: //special cases
			this.opacity = 1 - value;
			break;
		default:
			return false;
	}
	return true;
}

Material.prototype.getPropertyInfoFromPath = function( path )
{
	if( path.length &lt; 1)
		return;

	var varname = path[0];
	var type = null;

	switch(varname)
	{
		case &quot;opacity&quot;: 
		case &quot;transparency&quot;:
		case &quot;specular_factor&quot;:
		case &quot;specular_gloss&quot;:
		case &quot;reflection&quot;: 
		case &quot;blend_mode&quot;:
			type = &quot;number&quot;; break;
		//strings
		case &quot;shader_name&quot;:
		//bools
			type = &quot;string&quot;; break;
		//vectors
		case &quot;uvs_matrix&quot;:
			type = &quot;mat3&quot;; break;
		case &quot;color&quot;: 
			type = &quot;vec3&quot;; break;
		case &quot;textures&quot;:
			type = &quot;Texture&quot;; break;
		default:
			return null;
	}

	return {
		node: this._root,
		target: this,
		name: varname,
		value: this[varname],
		type: type
	};
}

/**
* gets all the texture channels supported by this material
* @method getTextureChannels
* @return {Array} array with the name of every channel supported by this material
*/
Material.prototype.getTextureChannels = function()
{
	if(this.constructor.texture_channels)
		return this.constructor.texture_channels;
	return [];
}

/**
* Assigns a texture to a channel and its sampling parameters
* @method setTexture
* @param {String} channel for a list of supported channels by this material call getTextureChannels()
* @param {Texture} texture
* @param {Object} sampler_options
*/
Material.prototype.setTexture = function( channel, texture, sampler_options ) {
	if(!channel)
		throw(&quot;Material.prototype.setTexture channel must be specified&quot;);

	if(!texture)
	{
		delete this.textures[channel];
		return;
	}

	var sampler = this.textures[channel];
	if(!sampler)
		this.textures[channel] = sampler = { texture: texture, uvs: Material.DEFAULT_UVS[channel] || &quot;0&quot;, wrap: 0, minFilter: 0, magFilter: 0 };
	else if(sampler.texture == texture)
		return sampler;
	else
		sampler.texture = texture;

	if(sampler_options)
		for(var i in sampler_options)
			sampler[i] = sampler_options[i];

	if(texture.constructor === String &amp;&amp; texture[0] != &quot;:&quot;)
		LS.ResourcesManager.load(texture);

	return sampler;
}

/**
* Set a property of the sampling (wrap, uvs, filter)
* @method setTextureProperty
* @param {String} channel for a list of supported channels by this material call getTextureChannels()
* @param {String} property could be &quot;uvs&quot;, &quot;filter&quot;, &quot;wrap&quot;
* @param {*} value the value, for uvs check Material.TEXTURE_COORDINATES, filter is gl.NEAREST or gl.LINEAR and wrap gl.CLAMP_TO_EDGE, gl.MIRROR or gl.REPEAT
*/
Material.prototype.setTextureProperty = function( channel, property, value )
{
	var sampler = this.textures[channel];

	if(!sampler)
	{
		if(property == &quot;texture&quot;)
			this.textures[channel] = sampler = { texture: value, uvs: Material.DEFAULT_UVS[channel] || &quot;0&quot;, wrap: 0, minFilter: 0, magFilter: 0 };
		return;
	}

	sampler[ property ] = value;
}

/**
* Returns the texture in a channel
* @method getTexture
* @param {String} channel default is COLOR
* @return {Texture}
*/
Material.prototype.getTexture = function( channel ) {
	channel = channel || Material.COLOR_TEXTURE;

	var v = this.textures[channel];
	if(!v) 
		return null;

	if(v.constructor === String)
		return LS.ResourcesManager.textures[v];

	var tex = v.texture;
	if(!tex)
		return null;
	if(tex.constructor === String)
		return LS.ResourcesManager.textures[tex];
	else if(tex.constructor == Texture)
		return tex;
	return null;
}

/**
* Returns the texture sampler info of one texture channel (filter, wrap, uvs)
* @method getTextureSampler
* @param {String} channel get available channels using getTextureChannels
* @return {Texture}
*/
Material.prototype.getTextureSampler = function(channel) {
	return this.textures[ channel ];
}

Material.getTextureFromSampler = function(sampler)
{
	var texture = sampler.constructor === String ? sampler : sampler.texture;
	if(!texture) //weird case
		return null;

	//fetch
	if(texture.constructor === String)
		texture = LS.ResourcesManager.textures[ texture ];
	
	if (!texture || texture.constructor != Texture)
		return null;
	return texture;
}

/**
* Assigns a texture sampler to one texture channel (filter, wrap, uvs)
* @method setTextureInfo
* @param {String} channel default is COLOR
* @param {Object} sampler { texture, uvs, wrap, filter }
*/
Material.prototype.setTextureSampler = function(channel, sampler) {
	if(!channel)
		throw(&quot;Cannot call Material setTextureSampler without channel&quot;);
	if(!sampler)
		delete this.textures[ channel ];
	else
		this.textures[ channel ] = sampler;
}

/**
* Collects all the resources needed by this material (textures)
* @method getResources
* @param {Object} resources object where all the resources are stored
* @return {Texture}
*/
Material.prototype.getResources = function (res)
{
	for(var i in this.textures)
	{
		var sampler = this.textures[i];
		if(!sampler) 
			continue;
		if(typeof(sampler.texture) == &quot;string&quot;)
			res[ sampler.texture ] = GL.Texture;
	}
	return res;
}

/**
* Event used to inform if one resource has changed its name
* @method onResourceRenamed
* @param {Object} resources object where all the resources are stored
* @return {Texture}
*/
Material.prototype.onResourceRenamed = function (old_name, new_name, resource)
{
	for(var i in this.textures)
	{
		var sampler = this.textures[i];
		if(!sampler)
			continue;
		if(sampler.texture == old_name)
			sampler.texture = new_name;
	}
}

/**
* Loads all the textures inside this material, by sending the through the ResourcesManager
* @method loadTextures
*/

Material.prototype.loadTextures = function ()
{
	var res = this.getResources({});
	for(var i in res)
		LS.ResourcesManager.load( i );
}

/**
* Register this material in a materials pool to be shared with other nodes
* @method registerMaterial
* @param {String} name name given to this material, it must be unique
*/
Material.prototype.registerMaterial = function(name)
{
	this.name = name;
	LS.ResourcesManager.registerResource(name, this);
	this.material = name;
}

Material.prototype.getCategory = function()
{
	return this.category || &quot;Material&quot;;
}

Material.prototype.updatePreview = function(size, options)
{
	options = options || {};

	var res = {};
	this.getResources(res);

	for(var i in res)
	{
		var resource = LS.ResourcesManager.resources[i];
		if(!resource)
		{
			console.warn(&quot;Cannot generate preview with resources missing.&quot;);
			return null;
		}
	}

	if(LS.GlobalScene.info.textures.environment)
		options.environment = LS.GlobalScene.info.textures.environment;

	size = size || 256;
	var preview = LS.Renderer.renderMaterialPreview( this, size, options );
	this.preview = preview;
	if(preview.toDataURL)
		this.preview_url = preview.toDataURL(&quot;image/png&quot;);
}

Material.prototype.getLocator = function()
{
	if(this._root)
		return this._root.uid + &quot;/material&quot;;
	return this.uid;
}

Material.processShaderCode = function(code)
{
	var lines = code.split(&quot;\n&quot;);
	for(var i in lines)
		lines[i] = lines[i].split(&quot;//&quot;)[0]; //remove comments
	code = lines.join(&quot;&quot;);
	if(!code)
		return null;
	return code;
}

Material.prototype.createProperty = function( name, value, type )
{
	if(type)
		this.constructor[ &quot;@&quot; + name ] = { type: type };

	//basic type
	if(value.constructor === Number || value.constructor === String || value.constructor === Boolean)
	{
		this[ name ] = value;
		return;
	}

	//vector type
	if(value.constructor === Float32Array)
	{
		var private_name = &quot;_&quot; + name;
		value = new Float32Array( value ); //clone
		this[ private_name ] = value; //this could be removed...

		Object.defineProperty( this, name, {
			get: function() { return value; },
			set: function(v) { value.set( v ); },
			enumerable: true
		});
	}
}


LS.registerMaterialClass(Material);
LS.Material = Material;
    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
